Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> class_decl program
Rule 2     program -> empty
Rule 3     empty -> <empty>
Rule 4     class_decl -> CLASS ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE
Rule 5     optionalExtendsId -> EXTENDS ID
Rule 6     optionalExtendsId -> empty
Rule 7     class_body_decl_plus -> class_body_decl
Rule 8     class_body_decl_plus -> class_body_decl class_body_decl_plus
Rule 9     class_body_decl -> field_decl
Rule 10    class_body_decl -> method_decl
Rule 11    class_body_decl -> constructor_decl
Rule 12    field_decl -> modifier var_decl
Rule 13    modifier -> public_private_zero_or_one static_zero_or_one
Rule 14    public_private_zero_or_one -> PUBLIC
Rule 15    public_private_zero_or_one -> PRIVATE
Rule 16    public_private_zero_or_one -> empty
Rule 17    static_zero_or_one -> STATIC
Rule 18    static_zero_or_one -> empty
Rule 19    var_decl -> type variables SEMI_COLON
Rule 20    type -> INT
Rule 21    type -> FLOAT
Rule 22    type -> BOOLEAN
Rule 23    type -> ID
Rule 24    variables -> variable additional_variables
Rule 25    additional_variables -> COMMA variable additional_variables
Rule 26    additional_variables -> empty
Rule 27    variable -> ID
Rule 28    method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block
Rule 29    method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block
Rule 30    zero_or_one_formals -> formals
Rule 31    zero_or_one_formals -> empty
Rule 32    constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block
Rule 33    formals -> formal_param additional_formal_params
Rule 34    additional_formal_params -> COMMA formal_param additional_formal_params
Rule 35    additional_formal_params -> empty
Rule 36    formal_param -> type variable
Rule 37    block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE
Rule 38    stmt_star -> stmt stmt_star
Rule 39    stmt_star -> empty
Rule 40    stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt
Rule 41    stmt -> WHILE L_PAREN expr R_PAREN stmt
Rule 42    stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
Rule 43    stmt -> RETURN zero_or_one_expr SEMI_COLON
Rule 44    stmt -> stmt_expr SEMI_COLON
Rule 45    stmt -> BREAK SEMI_COLON
Rule 46    stmt -> CONTINUE SEMI_COLON
Rule 47    stmt -> block
Rule 48    stmt -> var_decl
Rule 49    stmt -> SEMI_COLON
Rule 50    zero_or_one_else_stmt -> ELSE stmt
Rule 51    zero_or_one_else_stmt -> empty
Rule 52    zero_or_one_stmt_expr -> stmt_expr
Rule 53    zero_or_one_stmt_expr -> empty
Rule 54    zero_or_one_expr -> expr
Rule 55    zero_or_one_expr -> empty
Rule 56    literal -> INT_CONST
Rule 57    literal -> FLOAT_CONST
Rule 58    literal -> STRING_CONST
Rule 59    literal -> NULL
Rule 60    literal -> TRUE
Rule 61    literal -> FALSE
Rule 62    primary -> literal
Rule 63    primary -> THIS
Rule 64    primary -> SUPER
Rule 65    primary -> L_PAREN expr R_PAREN
Rule 66    primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN
Rule 67    primary -> lhs
Rule 68    primary -> method_invocation
Rule 69    zero_or_one_arguments -> arguments
Rule 70    zero_or_one_arguments -> empty
Rule 71    arguments -> expr additional_expr
Rule 72    additional_expr -> COMMA expr additional_expr
Rule 73    additional_expr -> empty
Rule 74    lhs -> field_access
Rule 75    field_access -> primary DOT ID
Rule 76    field_access -> ID
Rule 77    method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN
Rule 78    expr -> primary
Rule 79    expr -> assign
Rule 80    expr -> expr arith_op expr
Rule 81    expr -> expr bool_op expr
Rule 82    expr -> unary_op expr
Rule 83    assign -> lhs ASSIGNMENT_OP expr
Rule 84    assign -> lhs INCR_OP
Rule 85    assign -> INCR_OP lhs
Rule 86    assign -> lhs DECR_OP
Rule 87    assign -> DECR_OP lhs
Rule 88    arith_op -> PLUS
Rule 89    arith_op -> MINUS
Rule 90    arith_op -> TIMES
Rule 91    arith_op -> DIVIDE
Rule 92    bool_op -> LOGICAL_AND_OP
Rule 93    bool_op -> LOGICAL_OR_OP
Rule 94    bool_op -> EQUALITY_OP
Rule 95    bool_op -> DISEQUALITY_OP
Rule 96    bool_op -> L_THAN_OP
Rule 97    bool_op -> G_THAN_OP
Rule 98    bool_op -> L_THAN_EQUAL_TO_OP
Rule 99    bool_op -> G_THAN_EQUAL_TO_OP
Rule 100   unary_op -> PLUS
Rule 101   unary_op -> MINUS
Rule 102   unary_op -> NEG_OP
Rule 103   stmt_expr -> assign
Rule 104   stmt_expr -> method_invocation

Terminals, with rules where they appear

ASSIGNMENT_OP        : 83
BOOLEAN              : 22
BREAK                : 45
CLASS                : 4
COMMA                : 25 34 72
CONTINUE             : 46
DECR_OP              : 86 87
DISEQUALITY_OP       : 95
DIVIDE               : 91
DOT                  : 75
ELSE                 : 50
EQUALITY_OP          : 94
EXTENDS              : 5
FALSE                : 61
FLOAT                : 21
FLOAT_CONST          : 57
FOR                  : 42
G_THAN_EQUAL_TO_OP   : 99
G_THAN_OP            : 97
ID                   : 4 5 23 27 28 29 32 66 75 76
IF                   : 40
INCR_OP              : 84 85
INT                  : 20
INT_CONST            : 56
LOGICAL_AND_OP       : 92
LOGICAL_OR_OP        : 93
L_CURLY_BRACE        : 4 37
L_PAREN              : 28 29 32 40 41 42 65 66 77
L_THAN_EQUAL_TO_OP   : 98
L_THAN_OP            : 96
MINUS                : 89 101
NEG_OP               : 102
NEW                  : 66
NULL                 : 59
PLUS                 : 88 100
PRIVATE              : 15
PUBLIC               : 14
RETURN               : 43
R_CURLY_BRACE        : 4 37
R_PAREN              : 28 29 32 40 41 42 65 66 77
SEMI_COLON           : 19 42 42 43 44 45 46 49
STATIC               : 17
STRING_CONST         : 58
SUPER                : 64
THIS                 : 63
TIMES                : 90
TRUE                 : 60
VOID                 : 29
WHILE                : 41
error                : 

Nonterminals, with rules where they appear

additional_expr      : 71 72
additional_formal_params : 33 34
additional_variables : 24 25
arguments            : 69
arith_op             : 80
assign               : 79 103
block                : 28 29 32 47
bool_op              : 81
class_body_decl      : 7 8
class_body_decl_plus : 4 8
class_decl           : 1
constructor_decl     : 11
empty                : 2 6 16 18 26 31 35 39 51 53 55 70 73
expr                 : 40 41 54 65 71 72 80 80 81 81 82 83
field_access         : 74 77
field_decl           : 9
formal_param         : 33 34
formals              : 30
lhs                  : 67 83 84 85 86 87
literal              : 62
method_decl          : 10
method_invocation    : 68 104
modifier             : 12 28 29 32
optionalExtendsId    : 4
primary              : 75 78
program              : 1 0
public_private_zero_or_one : 13
static_zero_or_one   : 13
stmt                 : 38 40 41 42 50
stmt_expr            : 44 52
stmt_star            : 37 38
type                 : 19 28 36
unary_op             : 82
var_decl             : 12 48
variable             : 24 25 36
variables            : 19
zero_or_one_arguments : 66 77
zero_or_one_else_stmt : 40
zero_or_one_expr     : 42 43
zero_or_one_formals  : 28 29 32
zero_or_one_stmt_expr : 42 42

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_decl program
    (2) program -> . empty
    (4) class_decl -> . CLASS ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE
    (3) empty -> .

    CLASS           shift and go to state 4
    $end            reduce using rule 3 (empty -> .)

    program                        shift and go to state 1
    class_decl                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class_decl . program
    (1) program -> . class_decl program
    (2) program -> . empty
    (4) class_decl -> . CLASS ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE
    (3) empty -> .

    CLASS           shift and go to state 4
    $end            reduce using rule 3 (empty -> .)

    class_decl                     shift and go to state 2
    program                        shift and go to state 5
    empty                          shift and go to state 3

state 3

    (2) program -> empty .

    $end            reduce using rule 2 (program -> empty .)


state 4

    (4) class_decl -> CLASS . ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE

    ID              shift and go to state 6


state 5

    (1) program -> class_decl program .

    $end            reduce using rule 1 (program -> class_decl program .)


state 6

    (4) class_decl -> CLASS ID . optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE
    (5) optionalExtendsId -> . EXTENDS ID
    (6) optionalExtendsId -> . empty
    (3) empty -> .

    EXTENDS         shift and go to state 8
    L_CURLY_BRACE   reduce using rule 3 (empty -> .)

    optionalExtendsId              shift and go to state 7
    empty                          shift and go to state 9

state 7

    (4) class_decl -> CLASS ID optionalExtendsId . L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE

    L_CURLY_BRACE   shift and go to state 10


state 8

    (5) optionalExtendsId -> EXTENDS . ID

    ID              shift and go to state 11


state 9

    (6) optionalExtendsId -> empty .

    L_CURLY_BRACE   reduce using rule 6 (optionalExtendsId -> empty .)


state 10

    (4) class_decl -> CLASS ID optionalExtendsId L_CURLY_BRACE . class_body_decl_plus R_CURLY_BRACE
    (7) class_body_decl_plus -> . class_body_decl
    (8) class_body_decl_plus -> . class_body_decl class_body_decl_plus
    (9) class_body_decl -> . field_decl
    (10) class_body_decl -> . method_decl
    (11) class_body_decl -> . constructor_decl
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID L_PAREN zero_or_one_formals R_PAREN block
    (29) method_decl -> . modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block
    (32) constructor_decl -> . modifier ID L_PAREN zero_or_one_formals R_PAREN block
    (13) modifier -> . public_private_zero_or_one static_zero_or_one
    (14) public_private_zero_or_one -> . PUBLIC
    (15) public_private_zero_or_one -> . PRIVATE
    (16) public_private_zero_or_one -> . empty
    (3) empty -> .

    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          reduce using rule 3 (empty -> .)
    VOID            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)

    class_body_decl_plus           shift and go to state 12
    class_body_decl                shift and go to state 13
    field_decl                     shift and go to state 14
    method_decl                    shift and go to state 15
    constructor_decl               shift and go to state 16
    modifier                       shift and go to state 17
    public_private_zero_or_one     shift and go to state 18
    empty                          shift and go to state 21

state 11

    (5) optionalExtendsId -> EXTENDS ID .

    L_CURLY_BRACE   reduce using rule 5 (optionalExtendsId -> EXTENDS ID .)


state 12

    (4) class_decl -> CLASS ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus . R_CURLY_BRACE

    R_CURLY_BRACE   shift and go to state 22


state 13

    (7) class_body_decl_plus -> class_body_decl .
    (8) class_body_decl_plus -> class_body_decl . class_body_decl_plus
    (7) class_body_decl_plus -> . class_body_decl
    (8) class_body_decl_plus -> . class_body_decl class_body_decl_plus
    (9) class_body_decl -> . field_decl
    (10) class_body_decl -> . method_decl
    (11) class_body_decl -> . constructor_decl
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID L_PAREN zero_or_one_formals R_PAREN block
    (29) method_decl -> . modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block
    (32) constructor_decl -> . modifier ID L_PAREN zero_or_one_formals R_PAREN block
    (13) modifier -> . public_private_zero_or_one static_zero_or_one
    (14) public_private_zero_or_one -> . PUBLIC
    (15) public_private_zero_or_one -> . PRIVATE
    (16) public_private_zero_or_one -> . empty
    (3) empty -> .

    R_CURLY_BRACE   reduce using rule 7 (class_body_decl_plus -> class_body_decl .)
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          reduce using rule 3 (empty -> .)
    VOID            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)

    class_body_decl                shift and go to state 13
    class_body_decl_plus           shift and go to state 23
    field_decl                     shift and go to state 14
    method_decl                    shift and go to state 15
    constructor_decl               shift and go to state 16
    modifier                       shift and go to state 17
    public_private_zero_or_one     shift and go to state 18
    empty                          shift and go to state 21

state 14

    (9) class_body_decl -> field_decl .

    PUBLIC          reduce using rule 9 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl -> field_decl .)
    VOID            reduce using rule 9 (class_body_decl -> field_decl .)
    ID              reduce using rule 9 (class_body_decl -> field_decl .)
    INT             reduce using rule 9 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 9 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 9 (class_body_decl -> field_decl .)
    R_CURLY_BRACE   reduce using rule 9 (class_body_decl -> field_decl .)


state 15

    (10) class_body_decl -> method_decl .

    PUBLIC          reduce using rule 10 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl -> method_decl .)
    VOID            reduce using rule 10 (class_body_decl -> method_decl .)
    ID              reduce using rule 10 (class_body_decl -> method_decl .)
    INT             reduce using rule 10 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 10 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 10 (class_body_decl -> method_decl .)
    R_CURLY_BRACE   reduce using rule 10 (class_body_decl -> method_decl .)


state 16

    (11) class_body_decl -> constructor_decl .

    PUBLIC          reduce using rule 11 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 11 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 11 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 11 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> constructor_decl .)
    R_CURLY_BRACE   reduce using rule 11 (class_body_decl -> constructor_decl .)


state 17

    (12) field_decl -> modifier . var_decl
    (28) method_decl -> modifier . type ID L_PAREN zero_or_one_formals R_PAREN block
    (29) method_decl -> modifier . VOID ID L_PAREN zero_or_one_formals R_PAREN block
    (32) constructor_decl -> modifier . ID L_PAREN zero_or_one_formals R_PAREN block
    (19) var_decl -> . type variables SEMI_COLON
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    VOID            shift and go to state 27
    ID              shift and go to state 26
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30

    var_decl                       shift and go to state 24
    type                           shift and go to state 25

state 18

    (13) modifier -> public_private_zero_or_one . static_zero_or_one
    (17) static_zero_or_one -> . STATIC
    (18) static_zero_or_one -> . empty
    (3) empty -> .

    STATIC          shift and go to state 32
    VOID            reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)

    static_zero_or_one             shift and go to state 31
    empty                          shift and go to state 33

state 19

    (14) public_private_zero_or_one -> PUBLIC .

    STATIC          reduce using rule 14 (public_private_zero_or_one -> PUBLIC .)
    VOID            reduce using rule 14 (public_private_zero_or_one -> PUBLIC .)
    ID              reduce using rule 14 (public_private_zero_or_one -> PUBLIC .)
    INT             reduce using rule 14 (public_private_zero_or_one -> PUBLIC .)
    FLOAT           reduce using rule 14 (public_private_zero_or_one -> PUBLIC .)
    BOOLEAN         reduce using rule 14 (public_private_zero_or_one -> PUBLIC .)


state 20

    (15) public_private_zero_or_one -> PRIVATE .

    STATIC          reduce using rule 15 (public_private_zero_or_one -> PRIVATE .)
    VOID            reduce using rule 15 (public_private_zero_or_one -> PRIVATE .)
    ID              reduce using rule 15 (public_private_zero_or_one -> PRIVATE .)
    INT             reduce using rule 15 (public_private_zero_or_one -> PRIVATE .)
    FLOAT           reduce using rule 15 (public_private_zero_or_one -> PRIVATE .)
    BOOLEAN         reduce using rule 15 (public_private_zero_or_one -> PRIVATE .)


state 21

    (16) public_private_zero_or_one -> empty .

    STATIC          reduce using rule 16 (public_private_zero_or_one -> empty .)
    VOID            reduce using rule 16 (public_private_zero_or_one -> empty .)
    ID              reduce using rule 16 (public_private_zero_or_one -> empty .)
    INT             reduce using rule 16 (public_private_zero_or_one -> empty .)
    FLOAT           reduce using rule 16 (public_private_zero_or_one -> empty .)
    BOOLEAN         reduce using rule 16 (public_private_zero_or_one -> empty .)


state 22

    (4) class_decl -> CLASS ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE .)
    $end            reduce using rule 4 (class_decl -> CLASS ID optionalExtendsId L_CURLY_BRACE class_body_decl_plus R_CURLY_BRACE .)


state 23

    (8) class_body_decl_plus -> class_body_decl class_body_decl_plus .

    R_CURLY_BRACE   reduce using rule 8 (class_body_decl_plus -> class_body_decl class_body_decl_plus .)


state 24

    (12) field_decl -> modifier var_decl .

    PUBLIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 12 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 12 (field_decl -> modifier var_decl .)
    ID              reduce using rule 12 (field_decl -> modifier var_decl .)
    INT             reduce using rule 12 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 12 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 12 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    R_CURLY_BRACE   reduce using rule 12 (field_decl -> modifier var_decl .)


state 25

    (28) method_decl -> modifier type . ID L_PAREN zero_or_one_formals R_PAREN block
    (19) var_decl -> type . variables SEMI_COLON
    (24) variables -> . variable additional_variables
    (27) variable -> . ID

    ID              shift and go to state 34

    variables                      shift and go to state 35
    variable                       shift and go to state 36

state 26

    (32) constructor_decl -> modifier ID . L_PAREN zero_or_one_formals R_PAREN block
    (23) type -> ID .

    L_PAREN         shift and go to state 37
    ID              reduce using rule 23 (type -> ID .)


state 27

    (29) method_decl -> modifier VOID . ID L_PAREN zero_or_one_formals R_PAREN block

    ID              shift and go to state 38


state 28

    (20) type -> INT .

    ID              reduce using rule 20 (type -> INT .)


state 29

    (21) type -> FLOAT .

    ID              reduce using rule 21 (type -> FLOAT .)


state 30

    (22) type -> BOOLEAN .

    ID              reduce using rule 22 (type -> BOOLEAN .)


state 31

    (13) modifier -> public_private_zero_or_one static_zero_or_one .

    VOID            reduce using rule 13 (modifier -> public_private_zero_or_one static_zero_or_one .)
    ID              reduce using rule 13 (modifier -> public_private_zero_or_one static_zero_or_one .)
    INT             reduce using rule 13 (modifier -> public_private_zero_or_one static_zero_or_one .)
    FLOAT           reduce using rule 13 (modifier -> public_private_zero_or_one static_zero_or_one .)
    BOOLEAN         reduce using rule 13 (modifier -> public_private_zero_or_one static_zero_or_one .)


state 32

    (17) static_zero_or_one -> STATIC .

    VOID            reduce using rule 17 (static_zero_or_one -> STATIC .)
    ID              reduce using rule 17 (static_zero_or_one -> STATIC .)
    INT             reduce using rule 17 (static_zero_or_one -> STATIC .)
    FLOAT           reduce using rule 17 (static_zero_or_one -> STATIC .)
    BOOLEAN         reduce using rule 17 (static_zero_or_one -> STATIC .)


state 33

    (18) static_zero_or_one -> empty .

    VOID            reduce using rule 18 (static_zero_or_one -> empty .)
    ID              reduce using rule 18 (static_zero_or_one -> empty .)
    INT             reduce using rule 18 (static_zero_or_one -> empty .)
    FLOAT           reduce using rule 18 (static_zero_or_one -> empty .)
    BOOLEAN         reduce using rule 18 (static_zero_or_one -> empty .)


state 34

    (28) method_decl -> modifier type ID . L_PAREN zero_or_one_formals R_PAREN block
    (27) variable -> ID .

    L_PAREN         shift and go to state 39
    COMMA           reduce using rule 27 (variable -> ID .)
    SEMI_COLON      reduce using rule 27 (variable -> ID .)


state 35

    (19) var_decl -> type variables . SEMI_COLON

    SEMI_COLON      shift and go to state 40


state 36

    (24) variables -> variable . additional_variables
    (25) additional_variables -> . COMMA variable additional_variables
    (26) additional_variables -> . empty
    (3) empty -> .

    COMMA           shift and go to state 42
    SEMI_COLON      reduce using rule 3 (empty -> .)

    additional_variables           shift and go to state 41
    empty                          shift and go to state 43

state 37

    (32) constructor_decl -> modifier ID L_PAREN . zero_or_one_formals R_PAREN block
    (30) zero_or_one_formals -> . formals
    (31) zero_or_one_formals -> . empty
    (33) formals -> . formal_param additional_formal_params
    (3) empty -> .
    (36) formal_param -> . type variable
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    R_PAREN         reduce using rule 3 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 44

    zero_or_one_formals            shift and go to state 45
    formals                        shift and go to state 46
    empty                          shift and go to state 47
    formal_param                   shift and go to state 48
    type                           shift and go to state 49

state 38

    (29) method_decl -> modifier VOID ID . L_PAREN zero_or_one_formals R_PAREN block

    L_PAREN         shift and go to state 50


state 39

    (28) method_decl -> modifier type ID L_PAREN . zero_or_one_formals R_PAREN block
    (30) zero_or_one_formals -> . formals
    (31) zero_or_one_formals -> . empty
    (33) formals -> . formal_param additional_formal_params
    (3) empty -> .
    (36) formal_param -> . type variable
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    R_PAREN         reduce using rule 3 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 44

    type                           shift and go to state 49
    zero_or_one_formals            shift and go to state 51
    formals                        shift and go to state 46
    empty                          shift and go to state 47
    formal_param                   shift and go to state 48

state 40

    (19) var_decl -> type variables SEMI_COLON .

    PUBLIC          reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    PRIVATE         reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    VOID            reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    ID              reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    INT             reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    FLOAT           reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    BOOLEAN         reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    STATIC          reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    R_CURLY_BRACE   reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    IF              reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    WHILE           reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    FOR             reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    RETURN          reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    BREAK           reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    CONTINUE        reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    SEMI_COLON      reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    L_CURLY_BRACE   reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    INCR_OP         reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    DECR_OP         reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    THIS            reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    SUPER           reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    L_PAREN         reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    NEW             reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    INT_CONST       reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    FLOAT_CONST     reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    STRING_CONST    reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    NULL            reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    TRUE            reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    FALSE           reduce using rule 19 (var_decl -> type variables SEMI_COLON .)
    ELSE            reduce using rule 19 (var_decl -> type variables SEMI_COLON .)


state 41

    (24) variables -> variable additional_variables .

    SEMI_COLON      reduce using rule 24 (variables -> variable additional_variables .)


state 42

    (25) additional_variables -> COMMA . variable additional_variables
    (27) variable -> . ID

    ID              shift and go to state 53

    variable                       shift and go to state 52

state 43

    (26) additional_variables -> empty .

    SEMI_COLON      reduce using rule 26 (additional_variables -> empty .)


state 44

    (23) type -> ID .

    ID              reduce using rule 23 (type -> ID .)


state 45

    (32) constructor_decl -> modifier ID L_PAREN zero_or_one_formals . R_PAREN block

    R_PAREN         shift and go to state 54


state 46

    (30) zero_or_one_formals -> formals .

    R_PAREN         reduce using rule 30 (zero_or_one_formals -> formals .)


state 47

    (31) zero_or_one_formals -> empty .

    R_PAREN         reduce using rule 31 (zero_or_one_formals -> empty .)


state 48

    (33) formals -> formal_param . additional_formal_params
    (34) additional_formal_params -> . COMMA formal_param additional_formal_params
    (35) additional_formal_params -> . empty
    (3) empty -> .

    COMMA           shift and go to state 56
    R_PAREN         reduce using rule 3 (empty -> .)

    additional_formal_params       shift and go to state 55
    empty                          shift and go to state 57

state 49

    (36) formal_param -> type . variable
    (27) variable -> . ID

    ID              shift and go to state 53

    variable                       shift and go to state 58

state 50

    (29) method_decl -> modifier VOID ID L_PAREN . zero_or_one_formals R_PAREN block
    (30) zero_or_one_formals -> . formals
    (31) zero_or_one_formals -> . empty
    (33) formals -> . formal_param additional_formal_params
    (3) empty -> .
    (36) formal_param -> . type variable
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    R_PAREN         reduce using rule 3 (empty -> .)
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 44

    zero_or_one_formals            shift and go to state 59
    formals                        shift and go to state 46
    empty                          shift and go to state 47
    formal_param                   shift and go to state 48
    type                           shift and go to state 49

state 51

    (28) method_decl -> modifier type ID L_PAREN zero_or_one_formals . R_PAREN block

    R_PAREN         shift and go to state 60


state 52

    (25) additional_variables -> COMMA variable . additional_variables
    (25) additional_variables -> . COMMA variable additional_variables
    (26) additional_variables -> . empty
    (3) empty -> .

    COMMA           shift and go to state 42
    SEMI_COLON      reduce using rule 3 (empty -> .)

    additional_variables           shift and go to state 61
    empty                          shift and go to state 43

state 53

    (27) variable -> ID .

    COMMA           reduce using rule 27 (variable -> ID .)
    SEMI_COLON      reduce using rule 27 (variable -> ID .)
    R_PAREN         reduce using rule 27 (variable -> ID .)


state 54

    (32) constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN . block
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE

    L_CURLY_BRACE   shift and go to state 63

    block                          shift and go to state 62

state 55

    (33) formals -> formal_param additional_formal_params .

    R_PAREN         reduce using rule 33 (formals -> formal_param additional_formal_params .)


state 56

    (34) additional_formal_params -> COMMA . formal_param additional_formal_params
    (36) formal_param -> . type variable
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 44

    formal_param                   shift and go to state 64
    type                           shift and go to state 49

state 57

    (35) additional_formal_params -> empty .

    R_PAREN         reduce using rule 35 (additional_formal_params -> empty .)


state 58

    (36) formal_param -> type variable .

    COMMA           reduce using rule 36 (formal_param -> type variable .)
    R_PAREN         reduce using rule 36 (formal_param -> type variable .)


state 59

    (29) method_decl -> modifier VOID ID L_PAREN zero_or_one_formals . R_PAREN block

    R_PAREN         shift and go to state 65


state 60

    (28) method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN . block
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE

    L_CURLY_BRACE   shift and go to state 63

    block                          shift and go to state 66

state 61

    (25) additional_variables -> COMMA variable additional_variables .

    SEMI_COLON      reduce using rule 25 (additional_variables -> COMMA variable additional_variables .)


state 62

    (32) constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .

    PUBLIC          reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    PRIVATE         reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    VOID            reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    ID              reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    INT             reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    FLOAT           reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    BOOLEAN         reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    STATIC          reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)
    R_CURLY_BRACE   reduce using rule 32 (constructor_decl -> modifier ID L_PAREN zero_or_one_formals R_PAREN block .)


state 63

    (37) block -> L_CURLY_BRACE . stmt_star R_CURLY_BRACE
    (38) stmt_star -> . stmt stmt_star
    (39) stmt_star -> . empty
    (40) stmt -> . IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt
    (41) stmt -> . WHILE L_PAREN expr R_PAREN stmt
    (42) stmt -> . FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (43) stmt -> . RETURN zero_or_one_expr SEMI_COLON
    (44) stmt -> . stmt_expr SEMI_COLON
    (45) stmt -> . BREAK SEMI_COLON
    (46) stmt -> . CONTINUE SEMI_COLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMI_COLON
    (3) empty -> .
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE
    (19) var_decl -> . type variables SEMI_COLON
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 70
    WHILE           shift and go to state 72
    FOR             shift and go to state 73
    RETURN          shift and go to state 75
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    SEMI_COLON      shift and go to state 74
    R_CURLY_BRACE   reduce using rule 3 (empty -> .)
    L_CURLY_BRACE   shift and go to state 63
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 88
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    stmt_star                      shift and go to state 67
    stmt                           shift and go to state 68
    empty                          shift and go to state 69
    stmt_expr                      shift and go to state 76
    block                          shift and go to state 79
    var_decl                       shift and go to state 80
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    type                           shift and go to state 83
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 64

    (34) additional_formal_params -> COMMA formal_param . additional_formal_params
    (34) additional_formal_params -> . COMMA formal_param additional_formal_params
    (35) additional_formal_params -> . empty
    (3) empty -> .

    COMMA           shift and go to state 56
    R_PAREN         reduce using rule 3 (empty -> .)

    additional_formal_params       shift and go to state 100
    empty                          shift and go to state 57

state 65

    (29) method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN . block
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE

    L_CURLY_BRACE   shift and go to state 63

    block                          shift and go to state 101

state 66

    (28) method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .

    PUBLIC          reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    VOID            reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    ID              reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    STATIC          reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)
    R_CURLY_BRACE   reduce using rule 28 (method_decl -> modifier type ID L_PAREN zero_or_one_formals R_PAREN block .)


state 67

    (37) block -> L_CURLY_BRACE stmt_star . R_CURLY_BRACE

    R_CURLY_BRACE   shift and go to state 102


state 68

    (38) stmt_star -> stmt . stmt_star
    (38) stmt_star -> . stmt stmt_star
    (39) stmt_star -> . empty
    (40) stmt -> . IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt
    (41) stmt -> . WHILE L_PAREN expr R_PAREN stmt
    (42) stmt -> . FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (43) stmt -> . RETURN zero_or_one_expr SEMI_COLON
    (44) stmt -> . stmt_expr SEMI_COLON
    (45) stmt -> . BREAK SEMI_COLON
    (46) stmt -> . CONTINUE SEMI_COLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMI_COLON
    (3) empty -> .
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE
    (19) var_decl -> . type variables SEMI_COLON
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 70
    WHILE           shift and go to state 72
    FOR             shift and go to state 73
    RETURN          shift and go to state 75
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    SEMI_COLON      shift and go to state 74
    R_CURLY_BRACE   reduce using rule 3 (empty -> .)
    L_CURLY_BRACE   shift and go to state 63
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 88
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    stmt                           shift and go to state 68
    stmt_star                      shift and go to state 103
    empty                          shift and go to state 69
    stmt_expr                      shift and go to state 76
    block                          shift and go to state 79
    var_decl                       shift and go to state 80
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    type                           shift and go to state 83
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 69

    (39) stmt_star -> empty .

    R_CURLY_BRACE   reduce using rule 39 (stmt_star -> empty .)


state 70

    (40) stmt -> IF . L_PAREN expr R_PAREN stmt zero_or_one_else_stmt

    L_PAREN         shift and go to state 104


state 71

    (65) primary -> L_PAREN . expr R_PAREN
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    expr                           shift and go to state 105
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 72

    (41) stmt -> WHILE . L_PAREN expr R_PAREN stmt

    L_PAREN         shift and go to state 116


state 73

    (42) stmt -> FOR . L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt

    L_PAREN         shift and go to state 117


state 74

    (49) stmt -> SEMI_COLON .

    IF              reduce using rule 49 (stmt -> SEMI_COLON .)
    WHILE           reduce using rule 49 (stmt -> SEMI_COLON .)
    FOR             reduce using rule 49 (stmt -> SEMI_COLON .)
    RETURN          reduce using rule 49 (stmt -> SEMI_COLON .)
    BREAK           reduce using rule 49 (stmt -> SEMI_COLON .)
    CONTINUE        reduce using rule 49 (stmt -> SEMI_COLON .)
    SEMI_COLON      reduce using rule 49 (stmt -> SEMI_COLON .)
    L_CURLY_BRACE   reduce using rule 49 (stmt -> SEMI_COLON .)
    INCR_OP         reduce using rule 49 (stmt -> SEMI_COLON .)
    DECR_OP         reduce using rule 49 (stmt -> SEMI_COLON .)
    INT             reduce using rule 49 (stmt -> SEMI_COLON .)
    FLOAT           reduce using rule 49 (stmt -> SEMI_COLON .)
    BOOLEAN         reduce using rule 49 (stmt -> SEMI_COLON .)
    ID              reduce using rule 49 (stmt -> SEMI_COLON .)
    THIS            reduce using rule 49 (stmt -> SEMI_COLON .)
    SUPER           reduce using rule 49 (stmt -> SEMI_COLON .)
    L_PAREN         reduce using rule 49 (stmt -> SEMI_COLON .)
    NEW             reduce using rule 49 (stmt -> SEMI_COLON .)
    INT_CONST       reduce using rule 49 (stmt -> SEMI_COLON .)
    FLOAT_CONST     reduce using rule 49 (stmt -> SEMI_COLON .)
    STRING_CONST    reduce using rule 49 (stmt -> SEMI_COLON .)
    NULL            reduce using rule 49 (stmt -> SEMI_COLON .)
    TRUE            reduce using rule 49 (stmt -> SEMI_COLON .)
    FALSE           reduce using rule 49 (stmt -> SEMI_COLON .)
    R_CURLY_BRACE   reduce using rule 49 (stmt -> SEMI_COLON .)
    ELSE            reduce using rule 49 (stmt -> SEMI_COLON .)


state 75

    (43) stmt -> RETURN . zero_or_one_expr SEMI_COLON
    (54) zero_or_one_expr -> . expr
    (55) zero_or_one_expr -> . empty
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (3) empty -> .
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    SEMI_COLON      reduce using rule 3 (empty -> .)
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    zero_or_one_expr               shift and go to state 118
    expr                           shift and go to state 119
    empty                          shift and go to state 120
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 76

    (44) stmt -> stmt_expr . SEMI_COLON

    SEMI_COLON      shift and go to state 121


state 77

    (45) stmt -> BREAK . SEMI_COLON

    SEMI_COLON      shift and go to state 122


state 78

    (46) stmt -> CONTINUE . SEMI_COLON

    SEMI_COLON      shift and go to state 123


state 79

    (47) stmt -> block .

    IF              reduce using rule 47 (stmt -> block .)
    WHILE           reduce using rule 47 (stmt -> block .)
    FOR             reduce using rule 47 (stmt -> block .)
    RETURN          reduce using rule 47 (stmt -> block .)
    BREAK           reduce using rule 47 (stmt -> block .)
    CONTINUE        reduce using rule 47 (stmt -> block .)
    SEMI_COLON      reduce using rule 47 (stmt -> block .)
    L_CURLY_BRACE   reduce using rule 47 (stmt -> block .)
    INCR_OP         reduce using rule 47 (stmt -> block .)
    DECR_OP         reduce using rule 47 (stmt -> block .)
    INT             reduce using rule 47 (stmt -> block .)
    FLOAT           reduce using rule 47 (stmt -> block .)
    BOOLEAN         reduce using rule 47 (stmt -> block .)
    ID              reduce using rule 47 (stmt -> block .)
    THIS            reduce using rule 47 (stmt -> block .)
    SUPER           reduce using rule 47 (stmt -> block .)
    L_PAREN         reduce using rule 47 (stmt -> block .)
    NEW             reduce using rule 47 (stmt -> block .)
    INT_CONST       reduce using rule 47 (stmt -> block .)
    FLOAT_CONST     reduce using rule 47 (stmt -> block .)
    STRING_CONST    reduce using rule 47 (stmt -> block .)
    NULL            reduce using rule 47 (stmt -> block .)
    TRUE            reduce using rule 47 (stmt -> block .)
    FALSE           reduce using rule 47 (stmt -> block .)
    R_CURLY_BRACE   reduce using rule 47 (stmt -> block .)
    ELSE            reduce using rule 47 (stmt -> block .)


state 80

    (48) stmt -> var_decl .

    IF              reduce using rule 48 (stmt -> var_decl .)
    WHILE           reduce using rule 48 (stmt -> var_decl .)
    FOR             reduce using rule 48 (stmt -> var_decl .)
    RETURN          reduce using rule 48 (stmt -> var_decl .)
    BREAK           reduce using rule 48 (stmt -> var_decl .)
    CONTINUE        reduce using rule 48 (stmt -> var_decl .)
    SEMI_COLON      reduce using rule 48 (stmt -> var_decl .)
    L_CURLY_BRACE   reduce using rule 48 (stmt -> var_decl .)
    INCR_OP         reduce using rule 48 (stmt -> var_decl .)
    DECR_OP         reduce using rule 48 (stmt -> var_decl .)
    INT             reduce using rule 48 (stmt -> var_decl .)
    FLOAT           reduce using rule 48 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 48 (stmt -> var_decl .)
    ID              reduce using rule 48 (stmt -> var_decl .)
    THIS            reduce using rule 48 (stmt -> var_decl .)
    SUPER           reduce using rule 48 (stmt -> var_decl .)
    L_PAREN         reduce using rule 48 (stmt -> var_decl .)
    NEW             reduce using rule 48 (stmt -> var_decl .)
    INT_CONST       reduce using rule 48 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 48 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 48 (stmt -> var_decl .)
    NULL            reduce using rule 48 (stmt -> var_decl .)
    TRUE            reduce using rule 48 (stmt -> var_decl .)
    FALSE           reduce using rule 48 (stmt -> var_decl .)
    R_CURLY_BRACE   reduce using rule 48 (stmt -> var_decl .)
    ELSE            reduce using rule 48 (stmt -> var_decl .)


state 81

    (103) stmt_expr -> assign .

    SEMI_COLON      reduce using rule 103 (stmt_expr -> assign .)
    R_PAREN         reduce using rule 103 (stmt_expr -> assign .)


state 82

    (104) stmt_expr -> method_invocation .
    (68) primary -> method_invocation .

    SEMI_COLON      reduce using rule 104 (stmt_expr -> method_invocation .)
    R_PAREN         reduce using rule 104 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 68 (primary -> method_invocation .)


state 83

    (19) var_decl -> type . variables SEMI_COLON
    (24) variables -> . variable additional_variables
    (27) variable -> . ID

    ID              shift and go to state 53

    variables                      shift and go to state 35
    variable                       shift and go to state 36

state 84

    (83) assign -> lhs . ASSIGNMENT_OP expr
    (84) assign -> lhs . INCR_OP
    (86) assign -> lhs . DECR_OP
    (67) primary -> lhs .

    ASSIGNMENT_OP   shift and go to state 124
    INCR_OP         shift and go to state 125
    DECR_OP         shift and go to state 126
    DOT             reduce using rule 67 (primary -> lhs .)


state 85

    (85) assign -> INCR_OP . lhs
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN

    ID              shift and go to state 109
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    lhs                            shift and go to state 127
    field_access                   shift and go to state 115
    primary                        shift and go to state 89
    literal                        shift and go to state 90
    method_invocation              shift and go to state 111

state 86

    (87) assign -> DECR_OP . lhs
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN

    ID              shift and go to state 109
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    lhs                            shift and go to state 128
    field_access                   shift and go to state 115
    primary                        shift and go to state 89
    literal                        shift and go to state 90
    method_invocation              shift and go to state 111

state 87

    (77) method_invocation -> field_access . L_PAREN zero_or_one_arguments R_PAREN
    (74) lhs -> field_access .

    L_PAREN         shift and go to state 129
    ASSIGNMENT_OP   reduce using rule 74 (lhs -> field_access .)
    INCR_OP         reduce using rule 74 (lhs -> field_access .)
    DECR_OP         reduce using rule 74 (lhs -> field_access .)
    DOT             reduce using rule 74 (lhs -> field_access .)


state 88

    (23) type -> ID .
    (76) field_access -> ID .

    ID              reduce using rule 23 (type -> ID .)
    L_PAREN         reduce using rule 76 (field_access -> ID .)
    ASSIGNMENT_OP   reduce using rule 76 (field_access -> ID .)
    INCR_OP         reduce using rule 76 (field_access -> ID .)
    DECR_OP         reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)


state 89

    (75) field_access -> primary . DOT ID

    DOT             shift and go to state 130


state 90

    (62) primary -> literal .

    DOT             reduce using rule 62 (primary -> literal .)
    R_PAREN         reduce using rule 62 (primary -> literal .)
    PLUS            reduce using rule 62 (primary -> literal .)
    MINUS           reduce using rule 62 (primary -> literal .)
    TIMES           reduce using rule 62 (primary -> literal .)
    DIVIDE          reduce using rule 62 (primary -> literal .)
    LOGICAL_AND_OP  reduce using rule 62 (primary -> literal .)
    LOGICAL_OR_OP   reduce using rule 62 (primary -> literal .)
    EQUALITY_OP     reduce using rule 62 (primary -> literal .)
    DISEQUALITY_OP  reduce using rule 62 (primary -> literal .)
    L_THAN_OP       reduce using rule 62 (primary -> literal .)
    G_THAN_OP       reduce using rule 62 (primary -> literal .)
    L_THAN_EQUAL_TO_OP reduce using rule 62 (primary -> literal .)
    G_THAN_EQUAL_TO_OP reduce using rule 62 (primary -> literal .)
    SEMI_COLON      reduce using rule 62 (primary -> literal .)
    COMMA           reduce using rule 62 (primary -> literal .)


state 91

    (63) primary -> THIS .

    DOT             reduce using rule 63 (primary -> THIS .)
    R_PAREN         reduce using rule 63 (primary -> THIS .)
    PLUS            reduce using rule 63 (primary -> THIS .)
    MINUS           reduce using rule 63 (primary -> THIS .)
    TIMES           reduce using rule 63 (primary -> THIS .)
    DIVIDE          reduce using rule 63 (primary -> THIS .)
    LOGICAL_AND_OP  reduce using rule 63 (primary -> THIS .)
    LOGICAL_OR_OP   reduce using rule 63 (primary -> THIS .)
    EQUALITY_OP     reduce using rule 63 (primary -> THIS .)
    DISEQUALITY_OP  reduce using rule 63 (primary -> THIS .)
    L_THAN_OP       reduce using rule 63 (primary -> THIS .)
    G_THAN_OP       reduce using rule 63 (primary -> THIS .)
    L_THAN_EQUAL_TO_OP reduce using rule 63 (primary -> THIS .)
    G_THAN_EQUAL_TO_OP reduce using rule 63 (primary -> THIS .)
    SEMI_COLON      reduce using rule 63 (primary -> THIS .)
    COMMA           reduce using rule 63 (primary -> THIS .)


state 92

    (64) primary -> SUPER .

    DOT             reduce using rule 64 (primary -> SUPER .)
    R_PAREN         reduce using rule 64 (primary -> SUPER .)
    PLUS            reduce using rule 64 (primary -> SUPER .)
    MINUS           reduce using rule 64 (primary -> SUPER .)
    TIMES           reduce using rule 64 (primary -> SUPER .)
    DIVIDE          reduce using rule 64 (primary -> SUPER .)
    LOGICAL_AND_OP  reduce using rule 64 (primary -> SUPER .)
    LOGICAL_OR_OP   reduce using rule 64 (primary -> SUPER .)
    EQUALITY_OP     reduce using rule 64 (primary -> SUPER .)
    DISEQUALITY_OP  reduce using rule 64 (primary -> SUPER .)
    L_THAN_OP       reduce using rule 64 (primary -> SUPER .)
    G_THAN_OP       reduce using rule 64 (primary -> SUPER .)
    L_THAN_EQUAL_TO_OP reduce using rule 64 (primary -> SUPER .)
    G_THAN_EQUAL_TO_OP reduce using rule 64 (primary -> SUPER .)
    SEMI_COLON      reduce using rule 64 (primary -> SUPER .)
    COMMA           reduce using rule 64 (primary -> SUPER .)


state 93

    (66) primary -> NEW . ID L_PAREN zero_or_one_arguments R_PAREN

    ID              shift and go to state 131


state 94

    (56) literal -> INT_CONST .

    DOT             reduce using rule 56 (literal -> INT_CONST .)
    R_PAREN         reduce using rule 56 (literal -> INT_CONST .)
    PLUS            reduce using rule 56 (literal -> INT_CONST .)
    MINUS           reduce using rule 56 (literal -> INT_CONST .)
    TIMES           reduce using rule 56 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 56 (literal -> INT_CONST .)
    LOGICAL_AND_OP  reduce using rule 56 (literal -> INT_CONST .)
    LOGICAL_OR_OP   reduce using rule 56 (literal -> INT_CONST .)
    EQUALITY_OP     reduce using rule 56 (literal -> INT_CONST .)
    DISEQUALITY_OP  reduce using rule 56 (literal -> INT_CONST .)
    L_THAN_OP       reduce using rule 56 (literal -> INT_CONST .)
    G_THAN_OP       reduce using rule 56 (literal -> INT_CONST .)
    L_THAN_EQUAL_TO_OP reduce using rule 56 (literal -> INT_CONST .)
    G_THAN_EQUAL_TO_OP reduce using rule 56 (literal -> INT_CONST .)
    SEMI_COLON      reduce using rule 56 (literal -> INT_CONST .)
    COMMA           reduce using rule 56 (literal -> INT_CONST .)


state 95

    (57) literal -> FLOAT_CONST .

    DOT             reduce using rule 57 (literal -> FLOAT_CONST .)
    R_PAREN         reduce using rule 57 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 57 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 57 (literal -> FLOAT_CONST .)
    TIMES           reduce using rule 57 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 57 (literal -> FLOAT_CONST .)
    LOGICAL_AND_OP  reduce using rule 57 (literal -> FLOAT_CONST .)
    LOGICAL_OR_OP   reduce using rule 57 (literal -> FLOAT_CONST .)
    EQUALITY_OP     reduce using rule 57 (literal -> FLOAT_CONST .)
    DISEQUALITY_OP  reduce using rule 57 (literal -> FLOAT_CONST .)
    L_THAN_OP       reduce using rule 57 (literal -> FLOAT_CONST .)
    G_THAN_OP       reduce using rule 57 (literal -> FLOAT_CONST .)
    L_THAN_EQUAL_TO_OP reduce using rule 57 (literal -> FLOAT_CONST .)
    G_THAN_EQUAL_TO_OP reduce using rule 57 (literal -> FLOAT_CONST .)
    SEMI_COLON      reduce using rule 57 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 57 (literal -> FLOAT_CONST .)


state 96

    (58) literal -> STRING_CONST .

    DOT             reduce using rule 58 (literal -> STRING_CONST .)
    R_PAREN         reduce using rule 58 (literal -> STRING_CONST .)
    PLUS            reduce using rule 58 (literal -> STRING_CONST .)
    MINUS           reduce using rule 58 (literal -> STRING_CONST .)
    TIMES           reduce using rule 58 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 58 (literal -> STRING_CONST .)
    LOGICAL_AND_OP  reduce using rule 58 (literal -> STRING_CONST .)
    LOGICAL_OR_OP   reduce using rule 58 (literal -> STRING_CONST .)
    EQUALITY_OP     reduce using rule 58 (literal -> STRING_CONST .)
    DISEQUALITY_OP  reduce using rule 58 (literal -> STRING_CONST .)
    L_THAN_OP       reduce using rule 58 (literal -> STRING_CONST .)
    G_THAN_OP       reduce using rule 58 (literal -> STRING_CONST .)
    L_THAN_EQUAL_TO_OP reduce using rule 58 (literal -> STRING_CONST .)
    G_THAN_EQUAL_TO_OP reduce using rule 58 (literal -> STRING_CONST .)
    SEMI_COLON      reduce using rule 58 (literal -> STRING_CONST .)
    COMMA           reduce using rule 58 (literal -> STRING_CONST .)


state 97

    (59) literal -> NULL .

    DOT             reduce using rule 59 (literal -> NULL .)
    R_PAREN         reduce using rule 59 (literal -> NULL .)
    PLUS            reduce using rule 59 (literal -> NULL .)
    MINUS           reduce using rule 59 (literal -> NULL .)
    TIMES           reduce using rule 59 (literal -> NULL .)
    DIVIDE          reduce using rule 59 (literal -> NULL .)
    LOGICAL_AND_OP  reduce using rule 59 (literal -> NULL .)
    LOGICAL_OR_OP   reduce using rule 59 (literal -> NULL .)
    EQUALITY_OP     reduce using rule 59 (literal -> NULL .)
    DISEQUALITY_OP  reduce using rule 59 (literal -> NULL .)
    L_THAN_OP       reduce using rule 59 (literal -> NULL .)
    G_THAN_OP       reduce using rule 59 (literal -> NULL .)
    L_THAN_EQUAL_TO_OP reduce using rule 59 (literal -> NULL .)
    G_THAN_EQUAL_TO_OP reduce using rule 59 (literal -> NULL .)
    SEMI_COLON      reduce using rule 59 (literal -> NULL .)
    COMMA           reduce using rule 59 (literal -> NULL .)


state 98

    (60) literal -> TRUE .

    DOT             reduce using rule 60 (literal -> TRUE .)
    R_PAREN         reduce using rule 60 (literal -> TRUE .)
    PLUS            reduce using rule 60 (literal -> TRUE .)
    MINUS           reduce using rule 60 (literal -> TRUE .)
    TIMES           reduce using rule 60 (literal -> TRUE .)
    DIVIDE          reduce using rule 60 (literal -> TRUE .)
    LOGICAL_AND_OP  reduce using rule 60 (literal -> TRUE .)
    LOGICAL_OR_OP   reduce using rule 60 (literal -> TRUE .)
    EQUALITY_OP     reduce using rule 60 (literal -> TRUE .)
    DISEQUALITY_OP  reduce using rule 60 (literal -> TRUE .)
    L_THAN_OP       reduce using rule 60 (literal -> TRUE .)
    G_THAN_OP       reduce using rule 60 (literal -> TRUE .)
    L_THAN_EQUAL_TO_OP reduce using rule 60 (literal -> TRUE .)
    G_THAN_EQUAL_TO_OP reduce using rule 60 (literal -> TRUE .)
    SEMI_COLON      reduce using rule 60 (literal -> TRUE .)
    COMMA           reduce using rule 60 (literal -> TRUE .)


state 99

    (61) literal -> FALSE .

    DOT             reduce using rule 61 (literal -> FALSE .)
    R_PAREN         reduce using rule 61 (literal -> FALSE .)
    PLUS            reduce using rule 61 (literal -> FALSE .)
    MINUS           reduce using rule 61 (literal -> FALSE .)
    TIMES           reduce using rule 61 (literal -> FALSE .)
    DIVIDE          reduce using rule 61 (literal -> FALSE .)
    LOGICAL_AND_OP  reduce using rule 61 (literal -> FALSE .)
    LOGICAL_OR_OP   reduce using rule 61 (literal -> FALSE .)
    EQUALITY_OP     reduce using rule 61 (literal -> FALSE .)
    DISEQUALITY_OP  reduce using rule 61 (literal -> FALSE .)
    L_THAN_OP       reduce using rule 61 (literal -> FALSE .)
    G_THAN_OP       reduce using rule 61 (literal -> FALSE .)
    L_THAN_EQUAL_TO_OP reduce using rule 61 (literal -> FALSE .)
    G_THAN_EQUAL_TO_OP reduce using rule 61 (literal -> FALSE .)
    SEMI_COLON      reduce using rule 61 (literal -> FALSE .)
    COMMA           reduce using rule 61 (literal -> FALSE .)


state 100

    (34) additional_formal_params -> COMMA formal_param additional_formal_params .

    R_PAREN         reduce using rule 34 (additional_formal_params -> COMMA formal_param additional_formal_params .)


state 101

    (29) method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .

    PUBLIC          reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    PRIVATE         reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    VOID            reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    ID              reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    INT             reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    FLOAT           reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    BOOLEAN         reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    STATIC          reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)
    R_CURLY_BRACE   reduce using rule 29 (method_decl -> modifier VOID ID L_PAREN zero_or_one_formals R_PAREN block .)


state 102

    (37) block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .

    PUBLIC          reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    PRIVATE         reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    VOID            reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    ID              reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    INT             reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    FLOAT           reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    BOOLEAN         reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    STATIC          reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    R_CURLY_BRACE   reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    IF              reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    WHILE           reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    FOR             reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    RETURN          reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    BREAK           reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    CONTINUE        reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    SEMI_COLON      reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    L_CURLY_BRACE   reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    INCR_OP         reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    DECR_OP         reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    THIS            reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    SUPER           reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    L_PAREN         reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    NEW             reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    INT_CONST       reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    FLOAT_CONST     reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    STRING_CONST    reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    NULL            reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    TRUE            reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    FALSE           reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)
    ELSE            reduce using rule 37 (block -> L_CURLY_BRACE stmt_star R_CURLY_BRACE .)


state 103

    (38) stmt_star -> stmt stmt_star .

    R_CURLY_BRACE   reduce using rule 38 (stmt_star -> stmt stmt_star .)


state 104

    (40) stmt -> IF L_PAREN . expr R_PAREN stmt zero_or_one_else_stmt
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    expr                           shift and go to state 132
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 105

    (65) primary -> L_PAREN expr . R_PAREN
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

    R_PAREN         shift and go to state 133
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135

state 106

    (78) expr -> primary .
    (75) field_access -> primary . DOT ID

    R_PAREN         reduce using rule 78 (expr -> primary .)
    PLUS            reduce using rule 78 (expr -> primary .)
    MINUS           reduce using rule 78 (expr -> primary .)
    TIMES           reduce using rule 78 (expr -> primary .)
    DIVIDE          reduce using rule 78 (expr -> primary .)
    LOGICAL_AND_OP  reduce using rule 78 (expr -> primary .)
    LOGICAL_OR_OP   reduce using rule 78 (expr -> primary .)
    EQUALITY_OP     reduce using rule 78 (expr -> primary .)
    DISEQUALITY_OP  reduce using rule 78 (expr -> primary .)
    L_THAN_OP       reduce using rule 78 (expr -> primary .)
    G_THAN_OP       reduce using rule 78 (expr -> primary .)
    L_THAN_EQUAL_TO_OP reduce using rule 78 (expr -> primary .)
    G_THAN_EQUAL_TO_OP reduce using rule 78 (expr -> primary .)
    SEMI_COLON      reduce using rule 78 (expr -> primary .)
    COMMA           reduce using rule 78 (expr -> primary .)
    DOT             shift and go to state 130


state 107

    (79) expr -> assign .

    R_PAREN         reduce using rule 79 (expr -> assign .)
    PLUS            reduce using rule 79 (expr -> assign .)
    MINUS           reduce using rule 79 (expr -> assign .)
    TIMES           reduce using rule 79 (expr -> assign .)
    DIVIDE          reduce using rule 79 (expr -> assign .)
    LOGICAL_AND_OP  reduce using rule 79 (expr -> assign .)
    LOGICAL_OR_OP   reduce using rule 79 (expr -> assign .)
    EQUALITY_OP     reduce using rule 79 (expr -> assign .)
    DISEQUALITY_OP  reduce using rule 79 (expr -> assign .)
    L_THAN_OP       reduce using rule 79 (expr -> assign .)
    G_THAN_OP       reduce using rule 79 (expr -> assign .)
    L_THAN_EQUAL_TO_OP reduce using rule 79 (expr -> assign .)
    G_THAN_EQUAL_TO_OP reduce using rule 79 (expr -> assign .)
    SEMI_COLON      reduce using rule 79 (expr -> assign .)
    COMMA           reduce using rule 79 (expr -> assign .)


state 108

    (82) expr -> unary_op . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    unary_op                       shift and go to state 108
    expr                           shift and go to state 148
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 109

    (76) field_access -> ID .

    L_PAREN         reduce using rule 76 (field_access -> ID .)
    ASSIGNMENT_OP   reduce using rule 76 (field_access -> ID .)
    INCR_OP         reduce using rule 76 (field_access -> ID .)
    DECR_OP         reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)
    R_PAREN         reduce using rule 76 (field_access -> ID .)
    PLUS            reduce using rule 76 (field_access -> ID .)
    MINUS           reduce using rule 76 (field_access -> ID .)
    TIMES           reduce using rule 76 (field_access -> ID .)
    DIVIDE          reduce using rule 76 (field_access -> ID .)
    LOGICAL_AND_OP  reduce using rule 76 (field_access -> ID .)
    LOGICAL_OR_OP   reduce using rule 76 (field_access -> ID .)
    EQUALITY_OP     reduce using rule 76 (field_access -> ID .)
    DISEQUALITY_OP  reduce using rule 76 (field_access -> ID .)
    L_THAN_OP       reduce using rule 76 (field_access -> ID .)
    G_THAN_OP       reduce using rule 76 (field_access -> ID .)
    L_THAN_EQUAL_TO_OP reduce using rule 76 (field_access -> ID .)
    G_THAN_EQUAL_TO_OP reduce using rule 76 (field_access -> ID .)
    SEMI_COLON      reduce using rule 76 (field_access -> ID .)
    COMMA           reduce using rule 76 (field_access -> ID .)


state 110

    (67) primary -> lhs .
    (83) assign -> lhs . ASSIGNMENT_OP expr
    (84) assign -> lhs . INCR_OP
    (86) assign -> lhs . DECR_OP

    DOT             reduce using rule 67 (primary -> lhs .)
    R_PAREN         reduce using rule 67 (primary -> lhs .)
    PLUS            reduce using rule 67 (primary -> lhs .)
    MINUS           reduce using rule 67 (primary -> lhs .)
    TIMES           reduce using rule 67 (primary -> lhs .)
    DIVIDE          reduce using rule 67 (primary -> lhs .)
    LOGICAL_AND_OP  reduce using rule 67 (primary -> lhs .)
    LOGICAL_OR_OP   reduce using rule 67 (primary -> lhs .)
    EQUALITY_OP     reduce using rule 67 (primary -> lhs .)
    DISEQUALITY_OP  reduce using rule 67 (primary -> lhs .)
    L_THAN_OP       reduce using rule 67 (primary -> lhs .)
    G_THAN_OP       reduce using rule 67 (primary -> lhs .)
    L_THAN_EQUAL_TO_OP reduce using rule 67 (primary -> lhs .)
    G_THAN_EQUAL_TO_OP reduce using rule 67 (primary -> lhs .)
    SEMI_COLON      reduce using rule 67 (primary -> lhs .)
    COMMA           reduce using rule 67 (primary -> lhs .)
    ASSIGNMENT_OP   shift and go to state 124
    INCR_OP         shift and go to state 125
    DECR_OP         shift and go to state 126


state 111

    (68) primary -> method_invocation .

    DOT             reduce using rule 68 (primary -> method_invocation .)
    R_PAREN         reduce using rule 68 (primary -> method_invocation .)
    PLUS            reduce using rule 68 (primary -> method_invocation .)
    MINUS           reduce using rule 68 (primary -> method_invocation .)
    TIMES           reduce using rule 68 (primary -> method_invocation .)
    DIVIDE          reduce using rule 68 (primary -> method_invocation .)
    LOGICAL_AND_OP  reduce using rule 68 (primary -> method_invocation .)
    LOGICAL_OR_OP   reduce using rule 68 (primary -> method_invocation .)
    EQUALITY_OP     reduce using rule 68 (primary -> method_invocation .)
    DISEQUALITY_OP  reduce using rule 68 (primary -> method_invocation .)
    L_THAN_OP       reduce using rule 68 (primary -> method_invocation .)
    G_THAN_OP       reduce using rule 68 (primary -> method_invocation .)
    L_THAN_EQUAL_TO_OP reduce using rule 68 (primary -> method_invocation .)
    G_THAN_EQUAL_TO_OP reduce using rule 68 (primary -> method_invocation .)
    SEMI_COLON      reduce using rule 68 (primary -> method_invocation .)
    COMMA           reduce using rule 68 (primary -> method_invocation .)


state 112

    (100) unary_op -> PLUS .

    THIS            reduce using rule 100 (unary_op -> PLUS .)
    SUPER           reduce using rule 100 (unary_op -> PLUS .)
    L_PAREN         reduce using rule 100 (unary_op -> PLUS .)
    NEW             reduce using rule 100 (unary_op -> PLUS .)
    INCR_OP         reduce using rule 100 (unary_op -> PLUS .)
    DECR_OP         reduce using rule 100 (unary_op -> PLUS .)
    PLUS            reduce using rule 100 (unary_op -> PLUS .)
    MINUS           reduce using rule 100 (unary_op -> PLUS .)
    NEG_OP          reduce using rule 100 (unary_op -> PLUS .)
    INT_CONST       reduce using rule 100 (unary_op -> PLUS .)
    FLOAT_CONST     reduce using rule 100 (unary_op -> PLUS .)
    STRING_CONST    reduce using rule 100 (unary_op -> PLUS .)
    NULL            reduce using rule 100 (unary_op -> PLUS .)
    TRUE            reduce using rule 100 (unary_op -> PLUS .)
    FALSE           reduce using rule 100 (unary_op -> PLUS .)
    ID              reduce using rule 100 (unary_op -> PLUS .)


state 113

    (101) unary_op -> MINUS .

    THIS            reduce using rule 101 (unary_op -> MINUS .)
    SUPER           reduce using rule 101 (unary_op -> MINUS .)
    L_PAREN         reduce using rule 101 (unary_op -> MINUS .)
    NEW             reduce using rule 101 (unary_op -> MINUS .)
    INCR_OP         reduce using rule 101 (unary_op -> MINUS .)
    DECR_OP         reduce using rule 101 (unary_op -> MINUS .)
    PLUS            reduce using rule 101 (unary_op -> MINUS .)
    MINUS           reduce using rule 101 (unary_op -> MINUS .)
    NEG_OP          reduce using rule 101 (unary_op -> MINUS .)
    INT_CONST       reduce using rule 101 (unary_op -> MINUS .)
    FLOAT_CONST     reduce using rule 101 (unary_op -> MINUS .)
    STRING_CONST    reduce using rule 101 (unary_op -> MINUS .)
    NULL            reduce using rule 101 (unary_op -> MINUS .)
    TRUE            reduce using rule 101 (unary_op -> MINUS .)
    FALSE           reduce using rule 101 (unary_op -> MINUS .)
    ID              reduce using rule 101 (unary_op -> MINUS .)


state 114

    (102) unary_op -> NEG_OP .

    THIS            reduce using rule 102 (unary_op -> NEG_OP .)
    SUPER           reduce using rule 102 (unary_op -> NEG_OP .)
    L_PAREN         reduce using rule 102 (unary_op -> NEG_OP .)
    NEW             reduce using rule 102 (unary_op -> NEG_OP .)
    INCR_OP         reduce using rule 102 (unary_op -> NEG_OP .)
    DECR_OP         reduce using rule 102 (unary_op -> NEG_OP .)
    PLUS            reduce using rule 102 (unary_op -> NEG_OP .)
    MINUS           reduce using rule 102 (unary_op -> NEG_OP .)
    NEG_OP          reduce using rule 102 (unary_op -> NEG_OP .)
    INT_CONST       reduce using rule 102 (unary_op -> NEG_OP .)
    FLOAT_CONST     reduce using rule 102 (unary_op -> NEG_OP .)
    STRING_CONST    reduce using rule 102 (unary_op -> NEG_OP .)
    NULL            reduce using rule 102 (unary_op -> NEG_OP .)
    TRUE            reduce using rule 102 (unary_op -> NEG_OP .)
    FALSE           reduce using rule 102 (unary_op -> NEG_OP .)
    ID              reduce using rule 102 (unary_op -> NEG_OP .)


state 115

    (74) lhs -> field_access .
    (77) method_invocation -> field_access . L_PAREN zero_or_one_arguments R_PAREN

    ASSIGNMENT_OP   reduce using rule 74 (lhs -> field_access .)
    INCR_OP         reduce using rule 74 (lhs -> field_access .)
    DECR_OP         reduce using rule 74 (lhs -> field_access .)
    DOT             reduce using rule 74 (lhs -> field_access .)
    R_PAREN         reduce using rule 74 (lhs -> field_access .)
    PLUS            reduce using rule 74 (lhs -> field_access .)
    MINUS           reduce using rule 74 (lhs -> field_access .)
    TIMES           reduce using rule 74 (lhs -> field_access .)
    DIVIDE          reduce using rule 74 (lhs -> field_access .)
    LOGICAL_AND_OP  reduce using rule 74 (lhs -> field_access .)
    LOGICAL_OR_OP   reduce using rule 74 (lhs -> field_access .)
    EQUALITY_OP     reduce using rule 74 (lhs -> field_access .)
    DISEQUALITY_OP  reduce using rule 74 (lhs -> field_access .)
    L_THAN_OP       reduce using rule 74 (lhs -> field_access .)
    G_THAN_OP       reduce using rule 74 (lhs -> field_access .)
    L_THAN_EQUAL_TO_OP reduce using rule 74 (lhs -> field_access .)
    G_THAN_EQUAL_TO_OP reduce using rule 74 (lhs -> field_access .)
    SEMI_COLON      reduce using rule 74 (lhs -> field_access .)
    COMMA           reduce using rule 74 (lhs -> field_access .)
    L_PAREN         shift and go to state 129


state 116

    (41) stmt -> WHILE L_PAREN . expr R_PAREN stmt
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    expr                           shift and go to state 149
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 117

    (42) stmt -> FOR L_PAREN . zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (52) zero_or_one_stmt_expr -> . stmt_expr
    (53) zero_or_one_stmt_expr -> . empty
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (3) empty -> .
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    SEMI_COLON      reduce using rule 3 (empty -> .)
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    ID              shift and go to state 109
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    zero_or_one_stmt_expr          shift and go to state 150
    stmt_expr                      shift and go to state 151
    empty                          shift and go to state 152
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 118

    (43) stmt -> RETURN zero_or_one_expr . SEMI_COLON

    SEMI_COLON      shift and go to state 153


state 119

    (54) zero_or_one_expr -> expr .
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

    SEMI_COLON      reduce using rule 54 (zero_or_one_expr -> expr .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135

state 120

    (55) zero_or_one_expr -> empty .

    SEMI_COLON      reduce using rule 55 (zero_or_one_expr -> empty .)


state 121

    (44) stmt -> stmt_expr SEMI_COLON .

    IF              reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    WHILE           reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    FOR             reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    RETURN          reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    BREAK           reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    CONTINUE        reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    SEMI_COLON      reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    L_CURLY_BRACE   reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    INCR_OP         reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    DECR_OP         reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    INT             reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    FLOAT           reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    BOOLEAN         reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    ID              reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    THIS            reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    SUPER           reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    L_PAREN         reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    NEW             reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    INT_CONST       reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    FLOAT_CONST     reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    STRING_CONST    reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    NULL            reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    TRUE            reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    FALSE           reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    R_CURLY_BRACE   reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)
    ELSE            reduce using rule 44 (stmt -> stmt_expr SEMI_COLON .)


state 122

    (45) stmt -> BREAK SEMI_COLON .

    IF              reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    WHILE           reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    FOR             reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    RETURN          reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    BREAK           reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    CONTINUE        reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    SEMI_COLON      reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    L_CURLY_BRACE   reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    INCR_OP         reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    DECR_OP         reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    INT             reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    FLOAT           reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    BOOLEAN         reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    ID              reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    THIS            reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    SUPER           reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    L_PAREN         reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    NEW             reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    INT_CONST       reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    FLOAT_CONST     reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    STRING_CONST    reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    NULL            reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    TRUE            reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    FALSE           reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    R_CURLY_BRACE   reduce using rule 45 (stmt -> BREAK SEMI_COLON .)
    ELSE            reduce using rule 45 (stmt -> BREAK SEMI_COLON .)


state 123

    (46) stmt -> CONTINUE SEMI_COLON .

    IF              reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    WHILE           reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    FOR             reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    RETURN          reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    BREAK           reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    CONTINUE        reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    SEMI_COLON      reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    L_CURLY_BRACE   reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    INCR_OP         reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    DECR_OP         reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    INT             reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    FLOAT           reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    BOOLEAN         reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    ID              reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    THIS            reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    SUPER           reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    L_PAREN         reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    NEW             reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    INT_CONST       reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    FLOAT_CONST     reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    STRING_CONST    reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    NULL            reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    TRUE            reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    FALSE           reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    R_CURLY_BRACE   reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)
    ELSE            reduce using rule 46 (stmt -> CONTINUE SEMI_COLON .)


state 124

    (83) assign -> lhs ASSIGNMENT_OP . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    lhs                            shift and go to state 110
    expr                           shift and go to state 154
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 125

    (84) assign -> lhs INCR_OP .

    SEMI_COLON      reduce using rule 84 (assign -> lhs INCR_OP .)
    R_PAREN         reduce using rule 84 (assign -> lhs INCR_OP .)
    PLUS            reduce using rule 84 (assign -> lhs INCR_OP .)
    MINUS           reduce using rule 84 (assign -> lhs INCR_OP .)
    TIMES           reduce using rule 84 (assign -> lhs INCR_OP .)
    DIVIDE          reduce using rule 84 (assign -> lhs INCR_OP .)
    LOGICAL_AND_OP  reduce using rule 84 (assign -> lhs INCR_OP .)
    LOGICAL_OR_OP   reduce using rule 84 (assign -> lhs INCR_OP .)
    EQUALITY_OP     reduce using rule 84 (assign -> lhs INCR_OP .)
    DISEQUALITY_OP  reduce using rule 84 (assign -> lhs INCR_OP .)
    L_THAN_OP       reduce using rule 84 (assign -> lhs INCR_OP .)
    G_THAN_OP       reduce using rule 84 (assign -> lhs INCR_OP .)
    L_THAN_EQUAL_TO_OP reduce using rule 84 (assign -> lhs INCR_OP .)
    G_THAN_EQUAL_TO_OP reduce using rule 84 (assign -> lhs INCR_OP .)
    COMMA           reduce using rule 84 (assign -> lhs INCR_OP .)


state 126

    (86) assign -> lhs DECR_OP .

    SEMI_COLON      reduce using rule 86 (assign -> lhs DECR_OP .)
    R_PAREN         reduce using rule 86 (assign -> lhs DECR_OP .)
    PLUS            reduce using rule 86 (assign -> lhs DECR_OP .)
    MINUS           reduce using rule 86 (assign -> lhs DECR_OP .)
    TIMES           reduce using rule 86 (assign -> lhs DECR_OP .)
    DIVIDE          reduce using rule 86 (assign -> lhs DECR_OP .)
    LOGICAL_AND_OP  reduce using rule 86 (assign -> lhs DECR_OP .)
    LOGICAL_OR_OP   reduce using rule 86 (assign -> lhs DECR_OP .)
    EQUALITY_OP     reduce using rule 86 (assign -> lhs DECR_OP .)
    DISEQUALITY_OP  reduce using rule 86 (assign -> lhs DECR_OP .)
    L_THAN_OP       reduce using rule 86 (assign -> lhs DECR_OP .)
    G_THAN_OP       reduce using rule 86 (assign -> lhs DECR_OP .)
    L_THAN_EQUAL_TO_OP reduce using rule 86 (assign -> lhs DECR_OP .)
    G_THAN_EQUAL_TO_OP reduce using rule 86 (assign -> lhs DECR_OP .)
    COMMA           reduce using rule 86 (assign -> lhs DECR_OP .)


state 127

    (85) assign -> INCR_OP lhs .
    (67) primary -> lhs .

    SEMI_COLON      reduce using rule 85 (assign -> INCR_OP lhs .)
    R_PAREN         reduce using rule 85 (assign -> INCR_OP lhs .)
    PLUS            reduce using rule 85 (assign -> INCR_OP lhs .)
    MINUS           reduce using rule 85 (assign -> INCR_OP lhs .)
    TIMES           reduce using rule 85 (assign -> INCR_OP lhs .)
    DIVIDE          reduce using rule 85 (assign -> INCR_OP lhs .)
    LOGICAL_AND_OP  reduce using rule 85 (assign -> INCR_OP lhs .)
    LOGICAL_OR_OP   reduce using rule 85 (assign -> INCR_OP lhs .)
    EQUALITY_OP     reduce using rule 85 (assign -> INCR_OP lhs .)
    DISEQUALITY_OP  reduce using rule 85 (assign -> INCR_OP lhs .)
    L_THAN_OP       reduce using rule 85 (assign -> INCR_OP lhs .)
    G_THAN_OP       reduce using rule 85 (assign -> INCR_OP lhs .)
    L_THAN_EQUAL_TO_OP reduce using rule 85 (assign -> INCR_OP lhs .)
    G_THAN_EQUAL_TO_OP reduce using rule 85 (assign -> INCR_OP lhs .)
    COMMA           reduce using rule 85 (assign -> INCR_OP lhs .)
    DOT             reduce using rule 67 (primary -> lhs .)


state 128

    (87) assign -> DECR_OP lhs .
    (67) primary -> lhs .

    SEMI_COLON      reduce using rule 87 (assign -> DECR_OP lhs .)
    R_PAREN         reduce using rule 87 (assign -> DECR_OP lhs .)
    PLUS            reduce using rule 87 (assign -> DECR_OP lhs .)
    MINUS           reduce using rule 87 (assign -> DECR_OP lhs .)
    TIMES           reduce using rule 87 (assign -> DECR_OP lhs .)
    DIVIDE          reduce using rule 87 (assign -> DECR_OP lhs .)
    LOGICAL_AND_OP  reduce using rule 87 (assign -> DECR_OP lhs .)
    LOGICAL_OR_OP   reduce using rule 87 (assign -> DECR_OP lhs .)
    EQUALITY_OP     reduce using rule 87 (assign -> DECR_OP lhs .)
    DISEQUALITY_OP  reduce using rule 87 (assign -> DECR_OP lhs .)
    L_THAN_OP       reduce using rule 87 (assign -> DECR_OP lhs .)
    G_THAN_OP       reduce using rule 87 (assign -> DECR_OP lhs .)
    L_THAN_EQUAL_TO_OP reduce using rule 87 (assign -> DECR_OP lhs .)
    G_THAN_EQUAL_TO_OP reduce using rule 87 (assign -> DECR_OP lhs .)
    COMMA           reduce using rule 87 (assign -> DECR_OP lhs .)
    DOT             reduce using rule 67 (primary -> lhs .)


state 129

    (77) method_invocation -> field_access L_PAREN . zero_or_one_arguments R_PAREN
    (69) zero_or_one_arguments -> . arguments
    (70) zero_or_one_arguments -> . empty
    (71) arguments -> . expr additional_expr
    (3) empty -> .
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    R_PAREN         reduce using rule 3 (empty -> .)
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    field_access                   shift and go to state 115
    zero_or_one_arguments          shift and go to state 155
    arguments                      shift and go to state 156
    empty                          shift and go to state 157
    expr                           shift and go to state 158
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111

state 130

    (75) field_access -> primary DOT . ID

    ID              shift and go to state 159


state 131

    (66) primary -> NEW ID . L_PAREN zero_or_one_arguments R_PAREN

    L_PAREN         shift and go to state 160


state 132

    (40) stmt -> IF L_PAREN expr . R_PAREN stmt zero_or_one_else_stmt
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

    R_PAREN         shift and go to state 161
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135

state 133

    (65) primary -> L_PAREN expr R_PAREN .

    DOT             reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    TIMES           reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    LOGICAL_AND_OP  reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    LOGICAL_OR_OP   reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    EQUALITY_OP     reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    DISEQUALITY_OP  reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    L_THAN_OP       reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    G_THAN_OP       reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    L_THAN_EQUAL_TO_OP reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    G_THAN_EQUAL_TO_OP reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    SEMI_COLON      reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 65 (primary -> L_PAREN expr R_PAREN .)


state 134

    (80) expr -> expr arith_op . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    expr                           shift and go to state 162
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 135

    (81) expr -> expr bool_op . expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    expr                           shift and go to state 163
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 136

    (88) arith_op -> PLUS .

    THIS            reduce using rule 88 (arith_op -> PLUS .)
    SUPER           reduce using rule 88 (arith_op -> PLUS .)
    L_PAREN         reduce using rule 88 (arith_op -> PLUS .)
    NEW             reduce using rule 88 (arith_op -> PLUS .)
    INCR_OP         reduce using rule 88 (arith_op -> PLUS .)
    DECR_OP         reduce using rule 88 (arith_op -> PLUS .)
    PLUS            reduce using rule 88 (arith_op -> PLUS .)
    MINUS           reduce using rule 88 (arith_op -> PLUS .)
    NEG_OP          reduce using rule 88 (arith_op -> PLUS .)
    INT_CONST       reduce using rule 88 (arith_op -> PLUS .)
    FLOAT_CONST     reduce using rule 88 (arith_op -> PLUS .)
    STRING_CONST    reduce using rule 88 (arith_op -> PLUS .)
    NULL            reduce using rule 88 (arith_op -> PLUS .)
    TRUE            reduce using rule 88 (arith_op -> PLUS .)
    FALSE           reduce using rule 88 (arith_op -> PLUS .)
    ID              reduce using rule 88 (arith_op -> PLUS .)


state 137

    (89) arith_op -> MINUS .

    THIS            reduce using rule 89 (arith_op -> MINUS .)
    SUPER           reduce using rule 89 (arith_op -> MINUS .)
    L_PAREN         reduce using rule 89 (arith_op -> MINUS .)
    NEW             reduce using rule 89 (arith_op -> MINUS .)
    INCR_OP         reduce using rule 89 (arith_op -> MINUS .)
    DECR_OP         reduce using rule 89 (arith_op -> MINUS .)
    PLUS            reduce using rule 89 (arith_op -> MINUS .)
    MINUS           reduce using rule 89 (arith_op -> MINUS .)
    NEG_OP          reduce using rule 89 (arith_op -> MINUS .)
    INT_CONST       reduce using rule 89 (arith_op -> MINUS .)
    FLOAT_CONST     reduce using rule 89 (arith_op -> MINUS .)
    STRING_CONST    reduce using rule 89 (arith_op -> MINUS .)
    NULL            reduce using rule 89 (arith_op -> MINUS .)
    TRUE            reduce using rule 89 (arith_op -> MINUS .)
    FALSE           reduce using rule 89 (arith_op -> MINUS .)
    ID              reduce using rule 89 (arith_op -> MINUS .)


state 138

    (90) arith_op -> TIMES .

    THIS            reduce using rule 90 (arith_op -> TIMES .)
    SUPER           reduce using rule 90 (arith_op -> TIMES .)
    L_PAREN         reduce using rule 90 (arith_op -> TIMES .)
    NEW             reduce using rule 90 (arith_op -> TIMES .)
    INCR_OP         reduce using rule 90 (arith_op -> TIMES .)
    DECR_OP         reduce using rule 90 (arith_op -> TIMES .)
    PLUS            reduce using rule 90 (arith_op -> TIMES .)
    MINUS           reduce using rule 90 (arith_op -> TIMES .)
    NEG_OP          reduce using rule 90 (arith_op -> TIMES .)
    INT_CONST       reduce using rule 90 (arith_op -> TIMES .)
    FLOAT_CONST     reduce using rule 90 (arith_op -> TIMES .)
    STRING_CONST    reduce using rule 90 (arith_op -> TIMES .)
    NULL            reduce using rule 90 (arith_op -> TIMES .)
    TRUE            reduce using rule 90 (arith_op -> TIMES .)
    FALSE           reduce using rule 90 (arith_op -> TIMES .)
    ID              reduce using rule 90 (arith_op -> TIMES .)


state 139

    (91) arith_op -> DIVIDE .

    THIS            reduce using rule 91 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 91 (arith_op -> DIVIDE .)
    L_PAREN         reduce using rule 91 (arith_op -> DIVIDE .)
    NEW             reduce using rule 91 (arith_op -> DIVIDE .)
    INCR_OP         reduce using rule 91 (arith_op -> DIVIDE .)
    DECR_OP         reduce using rule 91 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 91 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 91 (arith_op -> DIVIDE .)
    NEG_OP          reduce using rule 91 (arith_op -> DIVIDE .)
    INT_CONST       reduce using rule 91 (arith_op -> DIVIDE .)
    FLOAT_CONST     reduce using rule 91 (arith_op -> DIVIDE .)
    STRING_CONST    reduce using rule 91 (arith_op -> DIVIDE .)
    NULL            reduce using rule 91 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 91 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 91 (arith_op -> DIVIDE .)
    ID              reduce using rule 91 (arith_op -> DIVIDE .)


state 140

    (92) bool_op -> LOGICAL_AND_OP .

    THIS            reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    SUPER           reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    L_PAREN         reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    NEW             reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    INCR_OP         reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    DECR_OP         reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    PLUS            reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    MINUS           reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    NEG_OP          reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    INT_CONST       reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    FLOAT_CONST     reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    STRING_CONST    reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    NULL            reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    TRUE            reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    FALSE           reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)
    ID              reduce using rule 92 (bool_op -> LOGICAL_AND_OP .)


state 141

    (93) bool_op -> LOGICAL_OR_OP .

    THIS            reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    SUPER           reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    L_PAREN         reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    NEW             reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    INCR_OP         reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    DECR_OP         reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    PLUS            reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    MINUS           reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    NEG_OP          reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    INT_CONST       reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    FLOAT_CONST     reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    STRING_CONST    reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    NULL            reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    TRUE            reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    FALSE           reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)
    ID              reduce using rule 93 (bool_op -> LOGICAL_OR_OP .)


state 142

    (94) bool_op -> EQUALITY_OP .

    THIS            reduce using rule 94 (bool_op -> EQUALITY_OP .)
    SUPER           reduce using rule 94 (bool_op -> EQUALITY_OP .)
    L_PAREN         reduce using rule 94 (bool_op -> EQUALITY_OP .)
    NEW             reduce using rule 94 (bool_op -> EQUALITY_OP .)
    INCR_OP         reduce using rule 94 (bool_op -> EQUALITY_OP .)
    DECR_OP         reduce using rule 94 (bool_op -> EQUALITY_OP .)
    PLUS            reduce using rule 94 (bool_op -> EQUALITY_OP .)
    MINUS           reduce using rule 94 (bool_op -> EQUALITY_OP .)
    NEG_OP          reduce using rule 94 (bool_op -> EQUALITY_OP .)
    INT_CONST       reduce using rule 94 (bool_op -> EQUALITY_OP .)
    FLOAT_CONST     reduce using rule 94 (bool_op -> EQUALITY_OP .)
    STRING_CONST    reduce using rule 94 (bool_op -> EQUALITY_OP .)
    NULL            reduce using rule 94 (bool_op -> EQUALITY_OP .)
    TRUE            reduce using rule 94 (bool_op -> EQUALITY_OP .)
    FALSE           reduce using rule 94 (bool_op -> EQUALITY_OP .)
    ID              reduce using rule 94 (bool_op -> EQUALITY_OP .)


state 143

    (95) bool_op -> DISEQUALITY_OP .

    THIS            reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    SUPER           reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    L_PAREN         reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    NEW             reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    INCR_OP         reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    DECR_OP         reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    PLUS            reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    MINUS           reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    NEG_OP          reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    INT_CONST       reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    FLOAT_CONST     reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    STRING_CONST    reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    NULL            reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    TRUE            reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    FALSE           reduce using rule 95 (bool_op -> DISEQUALITY_OP .)
    ID              reduce using rule 95 (bool_op -> DISEQUALITY_OP .)


state 144

    (96) bool_op -> L_THAN_OP .

    THIS            reduce using rule 96 (bool_op -> L_THAN_OP .)
    SUPER           reduce using rule 96 (bool_op -> L_THAN_OP .)
    L_PAREN         reduce using rule 96 (bool_op -> L_THAN_OP .)
    NEW             reduce using rule 96 (bool_op -> L_THAN_OP .)
    INCR_OP         reduce using rule 96 (bool_op -> L_THAN_OP .)
    DECR_OP         reduce using rule 96 (bool_op -> L_THAN_OP .)
    PLUS            reduce using rule 96 (bool_op -> L_THAN_OP .)
    MINUS           reduce using rule 96 (bool_op -> L_THAN_OP .)
    NEG_OP          reduce using rule 96 (bool_op -> L_THAN_OP .)
    INT_CONST       reduce using rule 96 (bool_op -> L_THAN_OP .)
    FLOAT_CONST     reduce using rule 96 (bool_op -> L_THAN_OP .)
    STRING_CONST    reduce using rule 96 (bool_op -> L_THAN_OP .)
    NULL            reduce using rule 96 (bool_op -> L_THAN_OP .)
    TRUE            reduce using rule 96 (bool_op -> L_THAN_OP .)
    FALSE           reduce using rule 96 (bool_op -> L_THAN_OP .)
    ID              reduce using rule 96 (bool_op -> L_THAN_OP .)


state 145

    (97) bool_op -> G_THAN_OP .

    THIS            reduce using rule 97 (bool_op -> G_THAN_OP .)
    SUPER           reduce using rule 97 (bool_op -> G_THAN_OP .)
    L_PAREN         reduce using rule 97 (bool_op -> G_THAN_OP .)
    NEW             reduce using rule 97 (bool_op -> G_THAN_OP .)
    INCR_OP         reduce using rule 97 (bool_op -> G_THAN_OP .)
    DECR_OP         reduce using rule 97 (bool_op -> G_THAN_OP .)
    PLUS            reduce using rule 97 (bool_op -> G_THAN_OP .)
    MINUS           reduce using rule 97 (bool_op -> G_THAN_OP .)
    NEG_OP          reduce using rule 97 (bool_op -> G_THAN_OP .)
    INT_CONST       reduce using rule 97 (bool_op -> G_THAN_OP .)
    FLOAT_CONST     reduce using rule 97 (bool_op -> G_THAN_OP .)
    STRING_CONST    reduce using rule 97 (bool_op -> G_THAN_OP .)
    NULL            reduce using rule 97 (bool_op -> G_THAN_OP .)
    TRUE            reduce using rule 97 (bool_op -> G_THAN_OP .)
    FALSE           reduce using rule 97 (bool_op -> G_THAN_OP .)
    ID              reduce using rule 97 (bool_op -> G_THAN_OP .)


state 146

    (98) bool_op -> L_THAN_EQUAL_TO_OP .

    THIS            reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    SUPER           reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    L_PAREN         reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    NEW             reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    INCR_OP         reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    DECR_OP         reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    PLUS            reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    MINUS           reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    NEG_OP          reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    INT_CONST       reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    FLOAT_CONST     reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    STRING_CONST    reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    NULL            reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    TRUE            reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    FALSE           reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)
    ID              reduce using rule 98 (bool_op -> L_THAN_EQUAL_TO_OP .)


state 147

    (99) bool_op -> G_THAN_EQUAL_TO_OP .

    THIS            reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    SUPER           reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    L_PAREN         reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    NEW             reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    INCR_OP         reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    DECR_OP         reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    PLUS            reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    MINUS           reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    NEG_OP          reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    INT_CONST       reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    FLOAT_CONST     reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    STRING_CONST    reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    NULL            reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    TRUE            reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    FALSE           reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)
    ID              reduce using rule 99 (bool_op -> G_THAN_EQUAL_TO_OP .)


state 148

    (82) expr -> unary_op expr .
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LOGICAL_AND_OP resolved as shift
  ! shift/reduce conflict for LOGICAL_OR_OP resolved as shift
  ! shift/reduce conflict for EQUALITY_OP resolved as shift
  ! shift/reduce conflict for DISEQUALITY_OP resolved as shift
  ! shift/reduce conflict for L_THAN_OP resolved as shift
  ! shift/reduce conflict for G_THAN_OP resolved as shift
  ! shift/reduce conflict for L_THAN_EQUAL_TO_OP resolved as shift
  ! shift/reduce conflict for G_THAN_EQUAL_TO_OP resolved as shift
    R_PAREN         reduce using rule 82 (expr -> unary_op expr .)
    SEMI_COLON      reduce using rule 82 (expr -> unary_op expr .)
    COMMA           reduce using rule 82 (expr -> unary_op expr .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

  ! PLUS            [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! MINUS           [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! TIMES           [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! DIVIDE          [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! LOGICAL_AND_OP  [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! LOGICAL_OR_OP   [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! EQUALITY_OP     [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! DISEQUALITY_OP  [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! L_THAN_OP       [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! G_THAN_OP       [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! L_THAN_EQUAL_TO_OP [ reduce using rule 82 (expr -> unary_op expr .) ]
  ! G_THAN_EQUAL_TO_OP [ reduce using rule 82 (expr -> unary_op expr .) ]

    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135

state 149

    (41) stmt -> WHILE L_PAREN expr . R_PAREN stmt
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

    R_PAREN         shift and go to state 164
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135

state 150

    (42) stmt -> FOR L_PAREN zero_or_one_stmt_expr . SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt

    SEMI_COLON      shift and go to state 165


state 151

    (52) zero_or_one_stmt_expr -> stmt_expr .

    SEMI_COLON      reduce using rule 52 (zero_or_one_stmt_expr -> stmt_expr .)
    R_PAREN         reduce using rule 52 (zero_or_one_stmt_expr -> stmt_expr .)


state 152

    (53) zero_or_one_stmt_expr -> empty .

    SEMI_COLON      reduce using rule 53 (zero_or_one_stmt_expr -> empty .)
    R_PAREN         reduce using rule 53 (zero_or_one_stmt_expr -> empty .)


state 153

    (43) stmt -> RETURN zero_or_one_expr SEMI_COLON .

    IF              reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    WHILE           reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    FOR             reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    RETURN          reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    BREAK           reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    CONTINUE        reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    SEMI_COLON      reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    L_CURLY_BRACE   reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    INCR_OP         reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    DECR_OP         reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    INT             reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    FLOAT           reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    BOOLEAN         reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    ID              reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    THIS            reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    SUPER           reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    L_PAREN         reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    NEW             reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    INT_CONST       reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    FLOAT_CONST     reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    STRING_CONST    reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    NULL            reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    TRUE            reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    FALSE           reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    R_CURLY_BRACE   reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)
    ELSE            reduce using rule 43 (stmt -> RETURN zero_or_one_expr SEMI_COLON .)


state 154

    (83) assign -> lhs ASSIGNMENT_OP expr .
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LOGICAL_AND_OP resolved as shift
  ! shift/reduce conflict for LOGICAL_OR_OP resolved as shift
  ! shift/reduce conflict for EQUALITY_OP resolved as shift
  ! shift/reduce conflict for DISEQUALITY_OP resolved as shift
  ! shift/reduce conflict for L_THAN_OP resolved as shift
  ! shift/reduce conflict for G_THAN_OP resolved as shift
  ! shift/reduce conflict for L_THAN_EQUAL_TO_OP resolved as shift
  ! shift/reduce conflict for G_THAN_EQUAL_TO_OP resolved as shift
    SEMI_COLON      reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .)
    R_PAREN         reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .)
    COMMA           reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

  ! PLUS            [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! MINUS           [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! TIMES           [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! DIVIDE          [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! LOGICAL_AND_OP  [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! LOGICAL_OR_OP   [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! EQUALITY_OP     [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! DISEQUALITY_OP  [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! L_THAN_OP       [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! G_THAN_OP       [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! L_THAN_EQUAL_TO_OP [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]
  ! G_THAN_EQUAL_TO_OP [ reduce using rule 83 (assign -> lhs ASSIGNMENT_OP expr .) ]

    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135

state 155

    (77) method_invocation -> field_access L_PAREN zero_or_one_arguments . R_PAREN

    R_PAREN         shift and go to state 166


state 156

    (69) zero_or_one_arguments -> arguments .

    R_PAREN         reduce using rule 69 (zero_or_one_arguments -> arguments .)


state 157

    (70) zero_or_one_arguments -> empty .

    R_PAREN         reduce using rule 70 (zero_or_one_arguments -> empty .)


state 158

    (71) arguments -> expr . additional_expr
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (72) additional_expr -> . COMMA expr additional_expr
    (73) additional_expr -> . empty
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP
    (3) empty -> .

    COMMA           shift and go to state 168
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147
    R_PAREN         reduce using rule 3 (empty -> .)

    additional_expr                shift and go to state 167
    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135
    empty                          shift and go to state 169

state 159

    (75) field_access -> primary DOT ID .

    L_PAREN         reduce using rule 75 (field_access -> primary DOT ID .)
    ASSIGNMENT_OP   reduce using rule 75 (field_access -> primary DOT ID .)
    INCR_OP         reduce using rule 75 (field_access -> primary DOT ID .)
    DECR_OP         reduce using rule 75 (field_access -> primary DOT ID .)
    DOT             reduce using rule 75 (field_access -> primary DOT ID .)
    R_PAREN         reduce using rule 75 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 75 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 75 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 75 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 75 (field_access -> primary DOT ID .)
    LOGICAL_AND_OP  reduce using rule 75 (field_access -> primary DOT ID .)
    LOGICAL_OR_OP   reduce using rule 75 (field_access -> primary DOT ID .)
    EQUALITY_OP     reduce using rule 75 (field_access -> primary DOT ID .)
    DISEQUALITY_OP  reduce using rule 75 (field_access -> primary DOT ID .)
    L_THAN_OP       reduce using rule 75 (field_access -> primary DOT ID .)
    G_THAN_OP       reduce using rule 75 (field_access -> primary DOT ID .)
    L_THAN_EQUAL_TO_OP reduce using rule 75 (field_access -> primary DOT ID .)
    G_THAN_EQUAL_TO_OP reduce using rule 75 (field_access -> primary DOT ID .)
    SEMI_COLON      reduce using rule 75 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 75 (field_access -> primary DOT ID .)


state 160

    (66) primary -> NEW ID L_PAREN . zero_or_one_arguments R_PAREN
    (69) zero_or_one_arguments -> . arguments
    (70) zero_or_one_arguments -> . empty
    (71) arguments -> . expr additional_expr
    (3) empty -> .
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    R_PAREN         reduce using rule 3 (empty -> .)
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    zero_or_one_arguments          shift and go to state 170
    arguments                      shift and go to state 156
    empty                          shift and go to state 157
    expr                           shift and go to state 158
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 161

    (40) stmt -> IF L_PAREN expr R_PAREN . stmt zero_or_one_else_stmt
    (40) stmt -> . IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt
    (41) stmt -> . WHILE L_PAREN expr R_PAREN stmt
    (42) stmt -> . FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (43) stmt -> . RETURN zero_or_one_expr SEMI_COLON
    (44) stmt -> . stmt_expr SEMI_COLON
    (45) stmt -> . BREAK SEMI_COLON
    (46) stmt -> . CONTINUE SEMI_COLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMI_COLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE
    (19) var_decl -> . type variables SEMI_COLON
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 70
    WHILE           shift and go to state 72
    FOR             shift and go to state 73
    RETURN          shift and go to state 75
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    SEMI_COLON      shift and go to state 74
    L_CURLY_BRACE   shift and go to state 63
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 88
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    stmt                           shift and go to state 171
    stmt_expr                      shift and go to state 76
    block                          shift and go to state 79
    var_decl                       shift and go to state 80
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    type                           shift and go to state 83
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 162

    (80) expr -> expr arith_op expr .
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LOGICAL_AND_OP resolved as shift
  ! shift/reduce conflict for LOGICAL_OR_OP resolved as shift
  ! shift/reduce conflict for EQUALITY_OP resolved as shift
  ! shift/reduce conflict for DISEQUALITY_OP resolved as shift
  ! shift/reduce conflict for L_THAN_OP resolved as shift
  ! shift/reduce conflict for G_THAN_OP resolved as shift
  ! shift/reduce conflict for L_THAN_EQUAL_TO_OP resolved as shift
  ! shift/reduce conflict for G_THAN_EQUAL_TO_OP resolved as shift
    R_PAREN         reduce using rule 80 (expr -> expr arith_op expr .)
    SEMI_COLON      reduce using rule 80 (expr -> expr arith_op expr .)
    COMMA           reduce using rule 80 (expr -> expr arith_op expr .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

  ! PLUS            [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! MINUS           [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! TIMES           [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! DIVIDE          [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! LOGICAL_AND_OP  [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! LOGICAL_OR_OP   [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! EQUALITY_OP     [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! DISEQUALITY_OP  [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! L_THAN_OP       [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! G_THAN_OP       [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! L_THAN_EQUAL_TO_OP [ reduce using rule 80 (expr -> expr arith_op expr .) ]
  ! G_THAN_EQUAL_TO_OP [ reduce using rule 80 (expr -> expr arith_op expr .) ]

    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135

state 163

    (81) expr -> expr bool_op expr .
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LOGICAL_AND_OP resolved as shift
  ! shift/reduce conflict for LOGICAL_OR_OP resolved as shift
  ! shift/reduce conflict for EQUALITY_OP resolved as shift
  ! shift/reduce conflict for DISEQUALITY_OP resolved as shift
  ! shift/reduce conflict for L_THAN_OP resolved as shift
  ! shift/reduce conflict for G_THAN_OP resolved as shift
  ! shift/reduce conflict for L_THAN_EQUAL_TO_OP resolved as shift
  ! shift/reduce conflict for G_THAN_EQUAL_TO_OP resolved as shift
    R_PAREN         reduce using rule 81 (expr -> expr bool_op expr .)
    SEMI_COLON      reduce using rule 81 (expr -> expr bool_op expr .)
    COMMA           reduce using rule 81 (expr -> expr bool_op expr .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147

  ! PLUS            [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! MINUS           [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! TIMES           [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! DIVIDE          [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! LOGICAL_AND_OP  [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! LOGICAL_OR_OP   [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! EQUALITY_OP     [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! DISEQUALITY_OP  [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! L_THAN_OP       [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! G_THAN_OP       [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! L_THAN_EQUAL_TO_OP [ reduce using rule 81 (expr -> expr bool_op expr .) ]
  ! G_THAN_EQUAL_TO_OP [ reduce using rule 81 (expr -> expr bool_op expr .) ]

    bool_op                        shift and go to state 135
    arith_op                       shift and go to state 134

state 164

    (41) stmt -> WHILE L_PAREN expr R_PAREN . stmt
    (40) stmt -> . IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt
    (41) stmt -> . WHILE L_PAREN expr R_PAREN stmt
    (42) stmt -> . FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (43) stmt -> . RETURN zero_or_one_expr SEMI_COLON
    (44) stmt -> . stmt_expr SEMI_COLON
    (45) stmt -> . BREAK SEMI_COLON
    (46) stmt -> . CONTINUE SEMI_COLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMI_COLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE
    (19) var_decl -> . type variables SEMI_COLON
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 70
    WHILE           shift and go to state 72
    FOR             shift and go to state 73
    RETURN          shift and go to state 75
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    SEMI_COLON      shift and go to state 74
    L_CURLY_BRACE   shift and go to state 63
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 88
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    stmt                           shift and go to state 172
    stmt_expr                      shift and go to state 76
    block                          shift and go to state 79
    var_decl                       shift and go to state 80
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    type                           shift and go to state 83
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 165

    (42) stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON . zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (54) zero_or_one_expr -> . expr
    (55) zero_or_one_expr -> . empty
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (3) empty -> .
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    SEMI_COLON      reduce using rule 3 (empty -> .)
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    zero_or_one_expr               shift and go to state 173
    expr                           shift and go to state 119
    empty                          shift and go to state 120
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 166

    (77) method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .

    SEMI_COLON      reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    DOT             reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    R_PAREN         reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    PLUS            reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    MINUS           reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    TIMES           reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    DIVIDE          reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    LOGICAL_AND_OP  reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    LOGICAL_OR_OP   reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    EQUALITY_OP     reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    DISEQUALITY_OP  reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    L_THAN_OP       reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    G_THAN_OP       reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    L_THAN_EQUAL_TO_OP reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    G_THAN_EQUAL_TO_OP reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)
    COMMA           reduce using rule 77 (method_invocation -> field_access L_PAREN zero_or_one_arguments R_PAREN .)


state 167

    (71) arguments -> expr additional_expr .

    R_PAREN         reduce using rule 71 (arguments -> expr additional_expr .)


state 168

    (72) additional_expr -> COMMA . expr additional_expr
    (78) expr -> . primary
    (79) expr -> . assign
    (80) expr -> . expr arith_op expr
    (81) expr -> . expr bool_op expr
    (82) expr -> . unary_op expr
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (100) unary_op -> . PLUS
    (101) unary_op -> . MINUS
    (102) unary_op -> . NEG_OP
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE
    (74) lhs -> . field_access
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    NEG_OP          shift and go to state 114
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 109

    expr                           shift and go to state 174
    primary                        shift and go to state 106
    assign                         shift and go to state 107
    unary_op                       shift and go to state 108
    literal                        shift and go to state 90
    lhs                            shift and go to state 110
    method_invocation              shift and go to state 111
    field_access                   shift and go to state 115

state 169

    (73) additional_expr -> empty .

    R_PAREN         reduce using rule 73 (additional_expr -> empty .)


state 170

    (66) primary -> NEW ID L_PAREN zero_or_one_arguments . R_PAREN

    R_PAREN         shift and go to state 175


state 171

    (40) stmt -> IF L_PAREN expr R_PAREN stmt . zero_or_one_else_stmt
    (50) zero_or_one_else_stmt -> . ELSE stmt
    (51) zero_or_one_else_stmt -> . empty
    (3) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 177
    IF              reduce using rule 3 (empty -> .)
    WHILE           reduce using rule 3 (empty -> .)
    FOR             reduce using rule 3 (empty -> .)
    RETURN          reduce using rule 3 (empty -> .)
    BREAK           reduce using rule 3 (empty -> .)
    CONTINUE        reduce using rule 3 (empty -> .)
    SEMI_COLON      reduce using rule 3 (empty -> .)
    L_CURLY_BRACE   reduce using rule 3 (empty -> .)
    INCR_OP         reduce using rule 3 (empty -> .)
    DECR_OP         reduce using rule 3 (empty -> .)
    INT             reduce using rule 3 (empty -> .)
    FLOAT           reduce using rule 3 (empty -> .)
    BOOLEAN         reduce using rule 3 (empty -> .)
    ID              reduce using rule 3 (empty -> .)
    THIS            reduce using rule 3 (empty -> .)
    SUPER           reduce using rule 3 (empty -> .)
    L_PAREN         reduce using rule 3 (empty -> .)
    NEW             reduce using rule 3 (empty -> .)
    INT_CONST       reduce using rule 3 (empty -> .)
    FLOAT_CONST     reduce using rule 3 (empty -> .)
    STRING_CONST    reduce using rule 3 (empty -> .)
    NULL            reduce using rule 3 (empty -> .)
    TRUE            reduce using rule 3 (empty -> .)
    FALSE           reduce using rule 3 (empty -> .)
    R_CURLY_BRACE   reduce using rule 3 (empty -> .)

  ! ELSE            [ reduce using rule 3 (empty -> .) ]

    zero_or_one_else_stmt          shift and go to state 176
    empty                          shift and go to state 178

state 172

    (41) stmt -> WHILE L_PAREN expr R_PAREN stmt .

    IF              reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    WHILE           reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    FOR             reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    RETURN          reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    BREAK           reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    CONTINUE        reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    SEMI_COLON      reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    L_CURLY_BRACE   reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    INCR_OP         reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    DECR_OP         reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    INT             reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    FLOAT           reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    ID              reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    THIS            reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    SUPER           reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    L_PAREN         reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    NEW             reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    INT_CONST       reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    FLOAT_CONST     reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    STRING_CONST    reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    NULL            reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    TRUE            reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    FALSE           reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    R_CURLY_BRACE   reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)
    ELSE            reduce using rule 41 (stmt -> WHILE L_PAREN expr R_PAREN stmt .)


state 173

    (42) stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr . SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt

    SEMI_COLON      shift and go to state 179


state 174

    (72) additional_expr -> COMMA expr . additional_expr
    (80) expr -> expr . arith_op expr
    (81) expr -> expr . bool_op expr
    (72) additional_expr -> . COMMA expr additional_expr
    (73) additional_expr -> . empty
    (88) arith_op -> . PLUS
    (89) arith_op -> . MINUS
    (90) arith_op -> . TIMES
    (91) arith_op -> . DIVIDE
    (92) bool_op -> . LOGICAL_AND_OP
    (93) bool_op -> . LOGICAL_OR_OP
    (94) bool_op -> . EQUALITY_OP
    (95) bool_op -> . DISEQUALITY_OP
    (96) bool_op -> . L_THAN_OP
    (97) bool_op -> . G_THAN_OP
    (98) bool_op -> . L_THAN_EQUAL_TO_OP
    (99) bool_op -> . G_THAN_EQUAL_TO_OP
    (3) empty -> .

    COMMA           shift and go to state 168
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    LOGICAL_AND_OP  shift and go to state 140
    LOGICAL_OR_OP   shift and go to state 141
    EQUALITY_OP     shift and go to state 142
    DISEQUALITY_OP  shift and go to state 143
    L_THAN_OP       shift and go to state 144
    G_THAN_OP       shift and go to state 145
    L_THAN_EQUAL_TO_OP shift and go to state 146
    G_THAN_EQUAL_TO_OP shift and go to state 147
    R_PAREN         reduce using rule 3 (empty -> .)

    additional_expr                shift and go to state 180
    arith_op                       shift and go to state 134
    bool_op                        shift and go to state 135
    empty                          shift and go to state 169

state 175

    (66) primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .

    DOT             reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    R_PAREN         reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    PLUS            reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    MINUS           reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    TIMES           reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    DIVIDE          reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    LOGICAL_AND_OP  reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    LOGICAL_OR_OP   reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    EQUALITY_OP     reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    DISEQUALITY_OP  reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    L_THAN_OP       reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    G_THAN_OP       reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    L_THAN_EQUAL_TO_OP reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    G_THAN_EQUAL_TO_OP reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    SEMI_COLON      reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)
    COMMA           reduce using rule 66 (primary -> NEW ID L_PAREN zero_or_one_arguments R_PAREN .)


state 176

    (40) stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .

    IF              reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    WHILE           reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    FOR             reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    RETURN          reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    BREAK           reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    SEMI_COLON      reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    L_CURLY_BRACE   reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    INCR_OP         reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    DECR_OP         reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    INT             reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    FLOAT           reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    ID              reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    THIS            reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    SUPER           reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    L_PAREN         reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    NEW             reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    INT_CONST       reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    STRING_CONST    reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    NULL            reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    TRUE            reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    FALSE           reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    R_CURLY_BRACE   reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)
    ELSE            reduce using rule 40 (stmt -> IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt .)


state 177

    (50) zero_or_one_else_stmt -> ELSE . stmt
    (40) stmt -> . IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt
    (41) stmt -> . WHILE L_PAREN expr R_PAREN stmt
    (42) stmt -> . FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (43) stmt -> . RETURN zero_or_one_expr SEMI_COLON
    (44) stmt -> . stmt_expr SEMI_COLON
    (45) stmt -> . BREAK SEMI_COLON
    (46) stmt -> . CONTINUE SEMI_COLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMI_COLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE
    (19) var_decl -> . type variables SEMI_COLON
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 70
    WHILE           shift and go to state 72
    FOR             shift and go to state 73
    RETURN          shift and go to state 75
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    SEMI_COLON      shift and go to state 74
    L_CURLY_BRACE   shift and go to state 63
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 88
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    stmt                           shift and go to state 181
    stmt_expr                      shift and go to state 76
    block                          shift and go to state 79
    var_decl                       shift and go to state 80
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    type                           shift and go to state 83
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 178

    (51) zero_or_one_else_stmt -> empty .

    ELSE            reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    IF              reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    WHILE           reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    FOR             reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    RETURN          reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    BREAK           reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    CONTINUE        reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    SEMI_COLON      reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    L_CURLY_BRACE   reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    INCR_OP         reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    DECR_OP         reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    INT             reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    FLOAT           reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    BOOLEAN         reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    ID              reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    THIS            reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    SUPER           reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    L_PAREN         reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    NEW             reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    INT_CONST       reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    FLOAT_CONST     reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    STRING_CONST    reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    NULL            reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    TRUE            reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    FALSE           reduce using rule 51 (zero_or_one_else_stmt -> empty .)
    R_CURLY_BRACE   reduce using rule 51 (zero_or_one_else_stmt -> empty .)


state 179

    (42) stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON . zero_or_one_stmt_expr R_PAREN stmt
    (52) zero_or_one_stmt_expr -> . stmt_expr
    (53) zero_or_one_stmt_expr -> . empty
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (3) empty -> .
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    R_PAREN         reduce using rule 3 (empty -> .)
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    ID              shift and go to state 109
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    zero_or_one_stmt_expr          shift and go to state 182
    stmt_expr                      shift and go to state 151
    empty                          shift and go to state 152
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 180

    (72) additional_expr -> COMMA expr additional_expr .

    R_PAREN         reduce using rule 72 (additional_expr -> COMMA expr additional_expr .)


state 181

    (50) zero_or_one_else_stmt -> ELSE stmt .

    ELSE            reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    IF              reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    WHILE           reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    FOR             reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    RETURN          reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    BREAK           reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    CONTINUE        reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    SEMI_COLON      reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    L_CURLY_BRACE   reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    INCR_OP         reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    DECR_OP         reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    INT             reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    FLOAT           reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    BOOLEAN         reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    ID              reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    THIS            reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    SUPER           reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    L_PAREN         reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    NEW             reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    INT_CONST       reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    FLOAT_CONST     reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    STRING_CONST    reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    NULL            reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    TRUE            reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    FALSE           reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)
    R_CURLY_BRACE   reduce using rule 50 (zero_or_one_else_stmt -> ELSE stmt .)


state 182

    (42) stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr . R_PAREN stmt

    R_PAREN         shift and go to state 183


state 183

    (42) stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN . stmt
    (40) stmt -> . IF L_PAREN expr R_PAREN stmt zero_or_one_else_stmt
    (41) stmt -> . WHILE L_PAREN expr R_PAREN stmt
    (42) stmt -> . FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt
    (43) stmt -> . RETURN zero_or_one_expr SEMI_COLON
    (44) stmt -> . stmt_expr SEMI_COLON
    (45) stmt -> . BREAK SEMI_COLON
    (46) stmt -> . CONTINUE SEMI_COLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMI_COLON
    (103) stmt_expr -> . assign
    (104) stmt_expr -> . method_invocation
    (37) block -> . L_CURLY_BRACE stmt_star R_CURLY_BRACE
    (19) var_decl -> . type variables SEMI_COLON
    (83) assign -> . lhs ASSIGNMENT_OP expr
    (84) assign -> . lhs INCR_OP
    (85) assign -> . INCR_OP lhs
    (86) assign -> . lhs DECR_OP
    (87) assign -> . DECR_OP lhs
    (77) method_invocation -> . field_access L_PAREN zero_or_one_arguments R_PAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (62) primary -> . literal
    (63) primary -> . THIS
    (64) primary -> . SUPER
    (65) primary -> . L_PAREN expr R_PAREN
    (66) primary -> . NEW ID L_PAREN zero_or_one_arguments R_PAREN
    (67) primary -> . lhs
    (68) primary -> . method_invocation
    (56) literal -> . INT_CONST
    (57) literal -> . FLOAT_CONST
    (58) literal -> . STRING_CONST
    (59) literal -> . NULL
    (60) literal -> . TRUE
    (61) literal -> . FALSE

    IF              shift and go to state 70
    WHILE           shift and go to state 72
    FOR             shift and go to state 73
    RETURN          shift and go to state 75
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    SEMI_COLON      shift and go to state 74
    L_CURLY_BRACE   shift and go to state 63
    INCR_OP         shift and go to state 85
    DECR_OP         shift and go to state 86
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    BOOLEAN         shift and go to state 30
    ID              shift and go to state 88
    THIS            shift and go to state 91
    SUPER           shift and go to state 92
    L_PAREN         shift and go to state 71
    NEW             shift and go to state 93
    INT_CONST       shift and go to state 94
    FLOAT_CONST     shift and go to state 95
    STRING_CONST    shift and go to state 96
    NULL            shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    stmt                           shift and go to state 184
    stmt_expr                      shift and go to state 76
    block                          shift and go to state 79
    var_decl                       shift and go to state 80
    assign                         shift and go to state 81
    method_invocation              shift and go to state 82
    type                           shift and go to state 83
    lhs                            shift and go to state 84
    field_access                   shift and go to state 87
    primary                        shift and go to state 89
    literal                        shift and go to state 90

state 184

    (42) stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .

    IF              reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    WHILE           reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    FOR             reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    RETURN          reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    BREAK           reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    CONTINUE        reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    SEMI_COLON      reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    L_CURLY_BRACE   reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    INCR_OP         reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    DECR_OP         reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    INT             reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    FLOAT           reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    BOOLEAN         reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    ID              reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    THIS            reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    SUPER           reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    L_PAREN         reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    NEW             reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    INT_CONST       reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    FLOAT_CONST     reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    STRING_CONST    reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    NULL            reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    TRUE            reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    FALSE           reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    R_CURLY_BRACE   reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)
    ELSE            reduce using rule 42 (stmt -> FOR L_PAREN zero_or_one_stmt_expr SEMI_COLON zero_or_one_expr SEMI_COLON zero_or_one_stmt_expr R_PAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for EQUALITY_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for DISEQUALITY_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for L_THAN_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for G_THAN_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for L_THAN_EQUAL_TO_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for G_THAN_EQUAL_TO_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 154 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 154 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 154 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for EQUALITY_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for DISEQUALITY_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for L_THAN_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for G_THAN_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for L_THAN_EQUAL_TO_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for G_THAN_EQUAL_TO_OP in state 154 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 162 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 162 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for EQUALITY_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for DISEQUALITY_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for L_THAN_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for G_THAN_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for L_THAN_EQUAL_TO_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for G_THAN_EQUAL_TO_OP in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 163 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 163 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for EQUALITY_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for DISEQUALITY_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for L_THAN_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for G_THAN_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for L_THAN_EQUAL_TO_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for G_THAN_EQUAL_TO_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 171 resolved as shift
